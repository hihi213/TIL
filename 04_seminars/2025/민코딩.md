- 분야 
	개발자들이라고 다 만들수있는건 아니다 게임개발자는 임베디드를 모른다
	- 임베디드 c
	- web 자바, 자바스크립트
	- 정보보안 자바
	- app 코틀린, 자바 스위프트
	- 게임c++
	- data(이건 세컨드로 가져가라 10년뒤에 먹고 살지 미지수이다)
	다해보고 결정할순 없다
- 비주얼 스튜디오
	- 솔루션 안에 프로젝트가 있다
	- 솔루션과 프로젝트를 동시에 만들고
	- 소스파일안에서 소스파일 만들어 소스짜는거임
	- control+ f5 으로 실행 만약 코드 문제있으면 에러남
	```c++ 암기
	#include <iostream>
	using namespace std;
	int main()
	{
		return 0;
	}
	```
	- trace: 한줄씩만 실행해 버그찾기(디버깅->버그 죽이는 활동)
		- 시작: f10 (창이 디버깅 모드가 됨)
		- 그후 f10으로 한줄씩 '실행'하는거임
		- 종료: shift+f5 누르거나 맨 아래 도착하면
	- 반복문이 있는경우 return있는줄에서 ctrl+f10 누르면(라인까지실행) 반복문 끝난 결과를 보여줌
		- ctrl f10하고 아래에 한번더 하면 그줄까지 실행된 결과를 보여줌 근데 위로 가서 ctrl f10하면 꺼짐(프로그램은 아래로 작동)
		- cout 를 중간중간 껴넣는것보다 빠르다.
		- 아니면 - F9: 중단점 설정-> F5 ->f5누르면 다음중단점 중단점없으면 종료
		- ctrl f5는 중단점에서도 안멈춤
	- 함수 만나면  f11누르면 함수 안으로 들어가짐 (그냥 지나치고 싶을땐 f10)
	-  F10 : 처음부터 한 줄씩 Trace하기 (Step Over, 함수 호출하는 코드에서 F10 누르면 함수 전체를 실행)
	- F11 : 한 줄씩 Trace하기 (Step In, 함수 호출하는 코드에서 F11 누르면 함수 내부로 진입)
	- Shift + F5 : Trace 종료하기 (디버깅 모드 종료)
	
- 빌드후 실행 : ctrl +f5
작성하신 디버깅 단축키와 설명은 전체적으로 정확하지만, 약간의 수정과 정리를 통해 더 명확하게 정리할 수 있습니다. 아래는 정리된 내용입니다.

**Visual Studio 디버깅 단축키 및 설명**

  

**1. Trace (한 줄씩 실행하며 디버깅)**

  

**목적: 코드 한 줄씩 실행하면서 변수 값과 흐름을 확인해 버그를 찾는 활동.**

• **시작: F10**

• 디버깅 모드로 전환하며, 한 줄씩 실행할 수 있는 상태가 됩니다.

• 디버깅 중 한 줄씩 코드 실행.

• **진행: F10**

• 현재 줄을 실행하고 다음 줄로 이동합니다.

• 함수 호출 시, 함수 내부로 들어가지 않고 함수 전체를 실행한 후 돌아옵니다 (**Step Over**).

• **종료: Shift + F5**

• 디버깅 모드를 종료합니다.

• 또는, 프로그램 실행이 끝나면 디버깅이 종료됩니다.

**2. 반복문 디버깅 시 (Ctrl + F10)**

  

**목적: 특정 줄까지 반복문 결과를 빠르게 확인.**

• **Ctrl + F10**: 현재 실행 위치부터 특정 줄까지 한 번에 실행.

• 반복문이 포함된 경우 반복이 끝난 결과를 빠르게 확인할 수 있습니다.

• 특정 줄에서 실행을 멈추고 결과를 보여줍니다.

• **주의**:

• **위쪽 코드로 Ctrl + F10을 실행하면 프로그램이 중단**되므로, 항상 **현재 실행 위치 아래 줄**에서 사용해야 합니다.

**3. 중단점(Breakpoint) 디버깅**

  

**목적: 특정 위치에서 프로그램 실행을 멈추고 디버깅.**

• **F9**: 현재 줄에 중단점(Breakpoint) 설정/해제.

• **F5**: 프로그램 실행.

• 중단점이 있는 경우 해당 지점에서 멈춤.

• 중단점이 없으면 프로그램이 종료될 때까지 실행.

• **Ctrl + F5**: 프로그램을 실행하지만, 중단점에서 멈추지 않고 전체를 실행.

**4. 함수 디버깅**

• **F10 (Step Over)**: 함수 호출 코드에서 **함수 전체를 실행**하고 다음 줄로 이동.

• **F11 (Step In)**: 함수 호출 코드에서 **함수 내부로 진입**해 디버깅.

**5. 디버깅 종료**

• **Shift + F5**: 디버깅 모드 종료.

**6. 빌드 후 실행**

• **Ctrl + F5**: 프로그램을 빌드하고 실행.

• 디버깅 없이 프로그램 전체 실행.

**정리된 단축키 요약**
f9->f5하고 return문으로 커서 움직여서 ctrl+f10하면 중단점에서 그사이 코드를 다 실행하고 return으로 이동함


|**단축키**|**기능**|
|---|---|
|**F10**|한 줄씩 실행 (**Step Over**, 함수 호출 시 함수 전체 실행)|
|**F11**|한 줄씩 실행 (**Step In**, 함수 내부로 진입)|
|**Ctrl + F10**|현재 위치에서 특정 줄까지 실행|
|**F9**|중단점(Breakpoint) 설정/해제|
|**F5**|프로그램 실행 (중단점이 있으면 중단점에서 멈춤)|
|**Ctrl + F5**|프로그램 실행 (중단점 무시, 전체 실행)|
|**Shift + F5**|디버깅 모드 종료|

**추가 설명:**

1. **Ctrl + F10**: 반복문이 있는 코드를 디버깅할 때, 특정 줄까지 빠르게 실행한 뒤 결과를 확인할 수 있어 **cout 디버깅보다 효율적**.

2. **중단점 디버깅(F9 + F5)**: 특정 지점에서만 코드 흐름을 확인하고 싶을 때 유용.

3. **F10 vs F11**:

• **F10 (Step Over)**: 함수 내부로 들어가지 않고, 함수 실행 후 바로 다음 줄로 이동.

• **F11 (Step In)**: 함수 내부로 진입해 세부 동작까지 디버깅.

- 이해를 목표로 하지 말고 능숙해지기 위해 노력하자
- 코딩은 ide에서 웹사이트에서 하지 말자
- 코딩은 할때마다 다 지우고 한다

- if/ for 변수 배열 함수 이 5가지가 c의 90프로다 여기다가 클래스가 추가된게 c++ 
	- 변수란?
		- 박스 int, char, double 이 3가지가 많이 저장됨
		- 박스 규칙
			1. 값을 넣기전 박스 이름을 지어주어야한다 int abc;
			2. 그후 값을 넣는다
	- 디버깅모드에서 변수가 생기는걸 볼수가 있다
	- cout로 변수를 출력하면 변수의 값이 출력된다.
- cout를 한줄로 적을수있다
	- cout<< "";
	- cout<< "";
	- -> cout << "" << "";
- int a= 3.2/2; a는 이때 1이 저장된다 
- a= a+1; -> a++;
	- 오른쪽이 먼저 실행되고
	- 저장이 그다음
- cout<< b++;
	- 이렇게 합쳐서 쓰지 말기 
	- cout<<b;
	- b++; 이렇게하기
- 내가 틀린것
	- cout << "\n"+ 정수형변수 가 작동할거라고 생각함
	- c++에서 문자열과 정수형은 덧셈이 불가능하다
	- (자바는 다른타입의 데이터 결합시 다른타입을 문자열로 자동변환해줌)
	- 한 줄에 한가지 역할만 하도록 구현하는게 한 줄의 목적이 명확합니다.코드 작성자의 의도가 명확하게 코딩해야합니다

- 컴공지식
	- 개천재 폰노이만의 아키택처
		- 저장장치에서 해독되서 cpu로 전달되는데 너무 속도가 차이나서 cpu가 노는 시간이 많아지니까 메모리를 둬야한다고 말함
		- cpu(반도체)-메모리(반도체)-저장장치
			- 저장장치-> 메모리 : 로딩
				- 그런데 메모리에서-> cpu 가는데 속도 차이나 cpu 또 놈
				- 그래서 cpu 내부에 메모리를 또 두고 덩어리로 전달==>캐시 메모리
				- DRAM(메모리) -> SRAM(캐시메모리)
	- cpu 시장
		- pc용 cpu: intel vs amd /설계, 마케팅,,,등등
		- 모바일용 cpu: arm(설계 독점),퀄컴,미드램(조립)
		- pc와 모바일 cpu기술의 차이(cpu회사인 인텔이 모바일cpu를 접수못한이유: 밥줄의 차이)
			- pc는 밥줄이 전봇대 전기라 최대한 가져올수있는 전기를 가져와 빨리 돌림 그래서 너무 발열발생해 선풍기 있음
			- 모바일은 밥줄이 배터리라 최대한 전기를 끌어오면 방전됨 그러므로 최대한 적게 쓰면서 돌려야함(삼성,애플)
	- 메모리시장
		- 1인자: 삼성
		- 2인자: sk
		- 3등: 미국
	- 저장장치
		- ssd: 삼성 
		- hdd: 미국
	- 그래픽카드
		- 앤비디아(arm 회사 인수)

- Shft+ space vm에서의 한영변환
- ctrl+ c/v vm에서의 복붙


2일차
- 변수 
	- 과정
		- 소스코드를 짠다
		- 빌드를 한다 (ctrl+f5)
			- 0과 1로 컴퓨터가 알아들을 수있는 명령어가 된다
		- (과거) cpu가 저장치에 있는 한줄을 가져가고 실행한다
			- cpu는 반도체라 속도가 매우 빠르다(전기의 속도)
			- 저장자치는 디스크라 모터의 속도이다
			- 그 속도의 차이로 cpu는 논다
		- (폰노이만 구조) 메모리의 등장
			- 우리가 실행하면 0과 1이 통으로 메모리에 옮겨지고(로드/ 로딩)
			- 메모리에서 cpu로 명령어를 보낸다
			- 메모리 제일 잘 만드는 나라 1등 삼성 2등 sk~~ 3등 미국
	- 입력
		- 변수를 만들어
			- 이때  쓰레기값 저장되어있어 초기화 시켜줘야 사용할수있음
			- c++에서는 컴파일은 성공했지만, 객체 파일을 연결(link)하는 과정에서 문제가 발생  그래서 c++에서는 지역변수는 반드시 초기화하고 사용해야함
			- 자바에서는 컴파일조차 안됨
		- 실행중인 프로그램에 값을 변수에 집어넣어
			- cout << x 
				- x를 출력(out)
				- <-데이터의 흐름
			- cin>> x
				- x에 입력(in)
				- 데이터의 흐름 ->
				- 두개 이상 입력시엔 cin>>x>>y;
					- cin>>x, y가아니다
	- 변수 선언은 컴파일 단계에 할당됨(코드에서 실행 이전에도 존재하게 됨)
- 조건문
	- if 
		참일때만 진입한다
		- 하나의 비교만을 한다.If(1<=x<=5) 불가
			- 파이썬은 연속비교를 자동으로 분리해 두개의 비교연산으로 처리하고 두 조건이 모두 참일때 참을 반환
			- 자바와 c++은 왼쪽부터 순차적으로 평가
				- 첫번째 1<=의 결과인 논리값을 정수로 변환한값(1 또는 0)와 <=5를 평가(항상참)
- 반복문
	1. i 재사용위해서 for 
		- int i=0; (변수를 처음에 만든다)
		- for(i=0; i<5; i++){
		}
	2. for문안에서 i 선언
- 언어 소개
	- c
	- c++ ->java
	- c++ ->c#
	- python
- 언어 설명
	- c
		- if, for , 변수, 배열, 함수 
	- c++, java, c#
		- if, for , 변수, 배열, 함수, 클래스
	- 그래서 언어 각각 모두 정복하자는 개념이 아니다. 언어를 잘하는게 아니라 코딩만 잘하면 된다.
	- 클래스 
		- 클래스 이전에는 함수단위로 코딩했음
			- 함수 단위로 코딩했던 기존코드를 다시쓸려면 수정이 필요
			- 클래스가 그래서 등장
		- 클래스란?
			- 관련있는 함수들을 포함하는 그룹
			- 클래스를 복붙하면 그대로 사용가능
			- 클래스의 등장으로 클래스 단위로 설계시작(객체 지향설계방식)
- 분야 소개
	- 자신의 전문분야 결정시키는 법 -> 탈락시키기
		- 게임: 게임 개좋아함
		- 정보보안: 해커 멋있으면..?
		- 임베비드: 삼성,sk 들어가고싶다, 전자제품, 기계
		- app: 누구나 쓸수있는, 사람이 아닌 자동으로 작동되는 프로그램
		- web: 누구나 쓸수있는 웹
아래가 제가 지피티써보고 이해한건데 이게 맞을까요? 

질문 1 : 변수를 선언하고 초기화하지 않고 출력할때 빌드가 안되는 현상의 이유는 아래와 같나요?
	- c++에서는 컴파일은 성공했지만, 객체 파일을 연결(link)하는 과정에서 문제가 발생  그래서 c++에서는 지역변수는 반드시 초기화하고 사용해야함
	- 자바에서는 컴파일조차 안됨

질문 2 : f10 눌렀을때 변수 선언하는 코드에 다다르기 전에도 변수가 존재하는 것처럼 보이는데 
	컴파일 단계에서 한번 흩을때 변수 선언코드는 실행됨 그래서 이미 메모리가 할당되어 존재하는것 

질문 3: If(1<=x<=5){}이 항상 참이 나오는 이유
	 자바와 c++은 순차적으로 왼쪽부터 판별하는데,
	 1<=x의 논리의 결과는 참이거나 거짓이다
	 그런데 그 논리의 결과(0또는 1)<=5는 항상 참이므로
	 결과는 항상 참이 된다 그래서 분리해서 조건문을 만들어야한다.
질문 4: 왜 for문 밖에 변수를 선언하고 그걸 사용하지 그냥 For(여기 안에 선언하고 사용하면 되자나) ()안에서는 선언이 c언어는 불가능한가?

- 4개의 수를 비교할때
```c++

#include <iostream>
using namespace std;

  

int main() {

int b1, b2, b3, b4;

cin >> b1 >> b2 >> b3 >> b4;

  

if (b1 >= b2) {

if (b1 >= b3) {

if (b1 >= b4) {

cout << "b1이 가장 크다";

}

}

}

  

  

return 0;

}
```


3일차
- 인터넷
	- 개인을 일일히 모두 연결해 통신하는게 아니라
	- 공유기와 개인을 연결해 공유기를 중심으뢰 정보가 왔다갔다하게 그리고 공유기를 늘려가는 방식으로 확장
- 인터넷 문제점 1
	- 컴퓨터 A의 공유폴더안의 문서를 사용할때 집갈려고 A컴퓨터를 끄면 다른 컴퓨터에서 그 문서를 사용 불가
	- 그래서 공용 컴퓨터를 하나 만들어서 공용컴퓨터에 문서에 저장하고 누구나 접속할수있게 24시간 켜둔다
	- 이 공용컴퓨터를 서버라고 한다.
	- 그리고 개개인의 컴퓨터에는 식별번호가 있는데 이걸 Ip라고 한다
- 인터넷 문제점2
	- 미국에서 한글문서는 안써서 한글문서를 볼수가 없음
	- 문서프로그램이 통일이 안됨
	- 전세계가 공통으로 사용하는 문서=> html
	- html의 문서를 읽어내는 프로그램=> 웹브라우저
		- 웹브라우저를 킨다
		- 서버에 고유번호(ip주소)를 입력한다
		- -> 문서 열람가능
			- 233.130.195.200
			- 네이버 서버 안에 있는 Html 문서(www.naver.com)
- 문서가 심심하다
	- 웹문서 안에다가 If, for 함수를 적용(자바 스크립트)
		- 그래서 웹 개발자가 생겼다
		- 단지 정보공유하는 문서가 아니라 게임도 할수있다
	- 접속하는 사람이 ip주소 입력시 서버가 소스코드를 주고,  접속하는 컴퓨터에서 빌드해 완성본을 보여줌
	- 이때 접속하는 컴퓨터를 클랑리언트라고 한다
- ip주소 외우기 어렵다
	- 중간에 dns라는 서버를 두고
	- naver.com== 233.130.195.200 이다고 저장
- 인터넷 == 웹문서 이렇게 국한된건 아니다
	- 인터넷하면 웹문서를 본다가 통상적이지만
	- 게임, 영상 시청도 가능


- trace는 문법적 오류가 없는 상태에서 해야한다
- for문
	- for(1, 2, 4){
		3
		}
	- 1번-> 2-> 3 > 4->2->3>4->2가 거짓이 될때까지 반복
	- 그러니까 x는 2가 거짓인 상태에서 종료
	- N번 반복하고 싶다
		- x=0; x< n; x++ 이렇게 하면 된다
	- a부터 b까지 출력하고 싶다
		- x=a; x<=b; x++
	- a부터 b까지 출력(내림)
		- x=b; x>=a; x--
	- 내가 구현 못한것(1,7,13,19..출력 (문제 잘못이해))
```
		for (int i = 0; i < 31;i+=6) {
		
		cout<<i<<" ";
		
		}	
```
- 정리
		1. **N번 반복**:
		• x < n: n번 반복하려면 마지막 인덱스는 n-1이므로, “작다(x < n)“를 사용.
		
		• 반복 횟수는 n번.
		
		2. **a부터 b까지**:
		
		• x <= b: b까지 포함하려면, “작거나 같다(x <= b)“를 사용.
		
		• 출력 범위는 a부터 b까지


4일차

- 운영체제(os)
	- 개발자는 앱을 만드는 사람이 많다
		웹의 수준이 높아서 웹앱이라고 부르기도 한다
	- 어플리케이션은 os안에서 돌아가는 얘들
		- os 없으면 안돌아감
		- 웹은 브라우저 없으면 안돌아감
	- 물리적인 하드웨어를 동작시키는것: os
		- windows
			- 윈도우 빼고 리눅스 생태계임
			- 일반사용자가 많이 씀
		- ios
			- unix가 바뀐게 ios
		- android
			- Linux가 바뀐게 android
		- Linux 
			- unix가 바뀐게 Linux
			- 화면이 나오는 전자제품(tv)
			- c언어로 만든 운영체제
			- 서버관련 개발자(웹)
	- 카레이서가 차의 구조를 알듯이 os를 알아야한다
		- os(프로그램)
			- 커널: os의 핵심소스코드
				- 리눅스는 os전체가 아니라 커널이다.
					- 리눅스를 가지고 만든 배포판: 우분투, 안드로이드
			- 기타등등
	- 운영체제를 다루는 방식
		1. GUI (그래픽기반)
			- 편함
			- 단점  
				- 과도한 선택 유도
				- 비효율적인 상호작용
				- 업데이트시 새로 익혀야함
		2. CLI (글자기반)
			- 명령어만 익혀두면 정말 편함
			- 큰 변화가 없음
			- 윈도우: 홈버튼+R누르고 cmd 엔터 누르면 들어가짐
			- 리눅스: 우분투(리눅스의 배포판)
	- 운영체제가 어떻게 하드웨어를 다루는지 공부 ㄱㄱ
- 배열
	- 변수를 여러개 한번에 만들때 사용
	- int 배열이름[변수개수]
		- 변수이름은 배열이름[변수번호]
		- 마지막 칸의 변수번호는: 변수개수-1
	- 초기화
		- 1. 일일히 값을 넣기
		- 2. 생성할때만 가능한 초기화
			- int 배열이름[변수개수]={배열 요소, , ...}
			- 생성된후에 이런식으로 배열요소를 넣을순 없다
			- int arr[6]= {0}; 하면 모든수가 0으로 초기화됨
				- 0이 아닌 다른수를 넣으면 첫번째 배열요소만 그 수로 초기화되고 나머진 0
				- int arr[6]={} 이렇게 해도 모든수가 0 으로 초기화 되는걸 발견함
- 하드코딩
	- cin 입력받아서 넣는게 아니고, 값을 소스코드에 적어두는것
		- ex) int v[6]={1,3,5,6,2,6};
- 저장장치 개발 썰
	- 검증, 개발이 5대 5비율로 인력임
	- 검증인력에서 개발인력 블랙리스트(농담)있음 개발인력 취조미팅하면서 왜 나는 그 버그를 방치했는가.. 설명해야함


- 5일차
	- 빌게이츠와 스티브잡스
		- hp, IBM이 미니 컴퓨터 제작하던 시절 워즈니악이랑 퍼스널 컴퓨터 pc사업을 시작한 스티브잡스
		- 스티브잡스가 대박이 나자 스티븐잡스의 컴퓨터를 거절했던 HP, IBM도 pc 사업을 시작
		- IBM 많은 하청업체 가짐 그래서 IBM이 정한 규격이 현대의 조립식 컴퓨터 규격이 됨(IBM계열 컴퓨터라고 부르기도 함)
		- 하드웨어는 준비됐는데 os가 없어서 이걸 산다고 신문에 공고~
		- 빌게이츠 이때 등장해서 dos라는 회사의 os꺼를 납부
		- 현재 우리가 살수있는 컴퓨터는 2가지 규격임
			- IBM규격(조립식 컴퓨터)
			- APPLE규격
		- 빌게이츠가 스티브잡스꺼 베껴 윈도우 3.0 대박
		- 빌게이츠가 많은 중소기업 죽이는 사업 많이함 (a기능 중소기업 a+b기능가진 제품 출시)\
		
	- 함수: 나만의 명령어를 만드는것
		- 반환 이름(아무것도 없을시 void로 침)
		- 명령어 사용하는걸 호출이라고 한다
		- c언어는 위에서 아래로 읽어서 함수선언이 위에 존재해야 호출할수있다
```c++
			void bts(){
			abc();// 오잉 abc를 읽은적이 없는데? -> 에러!
			}
			void abc(){
			}
			
```

```c++
			void abc();
			void bts(){
			abc();// abc 선언했었지-> 통과
			}
			void abc(){
			}
			
```
- 모든 프로그램은 main에서 시작하고 main에서 끝난다.
	- 변수
		- int
		- char
			- 한 글자
			- ' ' 를 사용함
				- b=a 일때 변수를 넣는건지 문자를 넣는건지 헷갈림
	- 전역변수
		- 지역변수: 함수안에서 선언시 그 함수안에서만 사용가능
			- main안에서 선언
			- 수동초기화
			- for문의 i는 전역하면 안됨.
		- 전역변수: 모든곳에서 사용가능
			- main밖에서 선언
			- 자동 초기화
- 생각못했던 코드
	- 0번 칸부터 시작하여 입력 받은 숫자만큼 배열을 건너 뛴 값을 출력 하고자 합니다.
```c++
for (x = 0; x < 11; x += input)  { 
cout << arr[x] << " "; 
}

```


6일차
- 전자과와 컴공의 차이
	- 전자과는 하드웨어부터-> os까지 만드는쪽
	- 컴공: 만들어진 os 위에서 만드는 어플리케이션을 만드는 쪽
- Low level, High level
	- low: 뿌리가 되는 os 
		- c언어 Only
	- high: os 위의 어플케이션을 만드는 high레벨
		- c,c++,자바,...등등
		- 
- 지난시간 이야기
	- 폰노이만 구조
		- 저장장치
			- 저장장치에서 코드를 빌드하면 0과 1이 되고 실행하면 메모리로 적재 그때의 메모리 영역은 코드영역이라고 함
		- 메모리
			- 변수를 만들면 메모리에 만들어지고 값은 메모리에 저장된다
			- 메모리 고유번호: 메모리주소
				- &변수 로 메모리 주소를 알아낼수 있음 이때의 &를 엠퍼센드라고 함
				- f10 누르고 조사식으로 &변수 등록하면 메모리번호 {저장된값} 이렇게 볼수있음
			- int는 4byte로 32개의 방(비트)을 사용하기로 약속되어 있다.
				- 변수의 주소는 첫번째 방의 주소이다
			- char는 1byte로 8비트이다
				- 1비트는 부호로 사용 그럼 7비트 256의 수를 표현 가능한데 부호있는수이므로 -128~127
				- '15'는 불가
					- 이건 문자 2개
				- Int나 char 나 숫자만 저장함 걍 사이즈 차이 컴퓨터는 숫자만 저장가능-> 변환표를 둔다(아스키코드)
					- 숫자 0이 아닌 문자 0은 아스키 코드 48번
					- 즉 프로그래밍에서는 숫자0과 문자0은 별개다.
					- cout는 출력할때 타입을 본다
						- char네? 숫자->문자로 변환 출력
						- int -> 숫자출력
						- 그냥 char+숫자-> char로 변환되어 저장
						- cout에서 char+숫자-> 더하면서 cout이 숫자로 착각해 타입을 숫자로 출력
						- 그래서 타입을 변경하는것: 캐스팅
							- (char)를 앞에 붙인다
						- '숫자'-'0'== 숫자
							- 아스키코드인걸 아스키코드 시작 번호를 뺌으로서 숫자를 구함 
							 [TIP] char 변수에 글자를 저장하면 글자를 저장한 것처럼
							보이지만 실제로는 숫자로 저장 됩니다.
							따라서 이러한 코드가 가능합니다.
							char one = 'A';
							char two = 65;
							컴퓨터 내부에는 두 코드 모두 숫자로 저장 되어있습니다.
							대신 출력하면 char 변수이기 때문에 문자로 출력 됩니다.
							
					- cin 입력할때 타입을 본다
						- char타입에 숫자 3 cin 입력-> 문자 3 즉 '3'-> 51이 저장됨
					- char a; a에 1저장하면 숫자 1의 아스키 코드 1이 저장
			- 근데 아스키 코드는 한국 글자가 없다 그래서 다른나라에서하면 글자가 깨진다.
				- 그래서 각국의 코드를 만들어 합친 표
				- 유니코드 등장
				- 조사식에 '문자' 등록하면 아스키코드 보인다.
					- 근데 변수>=65보다 변수>= 'A'이게 더 깔끔한 코드니 아스키코드를 알 필요가 없다.
		- cpu
			- 더빨리 실행하기 위해 cpu 내부에 메모리=> 캐시메모리
			

```c++
    for (char i = 'A';i <= 'Z';i++) {

        cout << i << " ";

}

    for (int i = 'A'; i <= 'Z';i++) {

        cout << (char)i << " ";

    }
```

```c++
	arr[i]=t;
	t++;

//이렇게 한줄로 바꿀수 있다
	arr[i]=t++;

```

- for문
	- i,j  쓰면 ||이랑 함께 헷갈림
	- 그래서 가로는 x 세로는 y 사용하기


7일차
- 개발 분야
	- 임베디드 분야
		- 소프트웨어 분야
			- 운영체제 동작을 c로 코딩
			- 아드웨어(체험용)
			- 오렌지보드 지니어스키트(10만원 하드웨어,소프트웨어다 들어있음)
			- 펌웨어 임베디드(작은 임베비드)
			- itos(기존 소프트웨어 수정해 새로)
			- 장점: 한번익히면 오래 써먹음
			- 단점: 노잼
		- 하드웨어 분야
- else if 사용하는경우
	- 순서가 중요하다
	- n>3 ,n>5, n>10 순으로 else if 하는경우
		- N>10은 실행이 안됨
		- 그래서 범위를 세부적으로 설정하거나, n>10이 제일 먼저 오게 순서를 수정.
- 탐색하다: 하나씩 요소를 살펴보다
- 2차원배열
	- for문에 무조건 Y가 먼저다. 앞칸이 세로축임
		- arr \[y] \[x]
	- 초기화 방법
		int arr\[3]\[2]= { {1,2},{5,7},{15,20} };

8일차

- api
	-  어떤기능을 쓰기위한 서비스(함수)들을 개발자들에게 제공
	- 증권사api
		- 증권사에서 개발자가 자동주식 프로그램 만들때 쓸수있도록 증권에서 만든 api(함수) 제공
		- 이렇게 주식매매
- win32api->windows api
	- window 운영체제의 있는 모든 기능들을 갔다쓰라고 만든 api
	- 윈도우 앱 개발자들은 windows api 가지고 개발함
	- 그래서 윈도우앱은 리녹스앱에서 실행x
	- api는 공식홈페이지에서 찾아쓰는게 대부분 외우지x
- \#include <windows.h>
	- win32api 함수들을 사용하기 위해서 써야함
- while(참일때 계속 반복하겠다)
	- for보다 불명확해서 for문보다 적게씀
	- 다만 무한히 반복할때 while
	- 쉽게 쓰는법
		시작값(초기화)
		while(중간값(조건)){
		증감값
		}

- 다차원 배열도 **메모리에서는 1차원 배열처럼 저장**되기 때문에, **중괄호 없이 한 줄로 초기화**해도 가능합니다.  int arr\[3]\[4] = { 1,3,4,1,3,4,6,1,1,1,1,1}; 가능

- 0 이외의 수는 참으로 인식함
	-1 도 참
- ctrl+ c는 콘솔창 멈춤


- 9일차
	- c언어 c++차이
```
scanf("%d", &n);
cin>>n;

printf("%d", n);
cout<<n;
```
- 9일차
	- 빌드 후 실행: ctrl+f5
	- 디버그모드(슬로우 모드로) trace 시작하면서 step over (한줄씩 over로 실행): f10
	- 디버그모드 trace하면서 step into( 한줄씩 함수안을 들어가며 실행) : f11
	- 디버그모드 끄기 :  shift +f10
	- 디버그모드에서 원하는 부분만 살펴보고 싶다!
		- 중단점 설정/취소: 라인클릭후 f9 
		- 중단점까지 실행: f5
	- 구조체
		- 타입은 데이터의 종류이다.
		- struct 구조체이름
			{
			int a;
			int b;
			};
	- call by value
		- 함수 호출하면서 데이터 보냄
	- 함수 선언시 주의점
		- 매걔변수에 Int a,b이런식으로 선언 금지
			- 변수 선언에는 , 가 같은 자료형을 공유하지만 함수 매걔변수는 , 함수매걔변수에서는 각각 독립적으로 자료형을 가져야함
		- 매걔변수를 재선언 하지말자
			- 이미 할당된 메모리와 충돌
	- 배열
		배열에  한꺼번에 숫자를 넣는 것은 배열 만들때만가능합니다.
		int vect[5] = { 1, 2, 3, 4 };// 가능
		vect[5] = { 1, 2, 3, 4};// Runtime Error
		배열을 만들고 난 뒤에는숫자를 하나씩 넣어줘야 합니다.

  
10일차
- 라이브러리: 남들이 가져가라고 만든 소스코드 (iostream)
	- 가져다 쓰는 방법 \#include
		- header파일+ 소스코드 포함
		- header파일+ 소스코드 비공개
			- header파일로 함수 호출힐수있게 함
	- \#include <c++ 공식라이브러리>
	- \#include "내가 만든라이브러리"
	- 헤더파일은 빌드 안하고 cpp코드만 빌드한다.
	- \#include는 복붙이다
		- \#include "header.h"이러면
		- header.h에 써있는 코드가 그대로 그자리에 복붙되는 거임
		- 즉 함수선언을 맨위에 해버려 빌드가 가능하게 함
- 함수 선언만 위에하고 아래에 실행문쓰기 가능
- 오픈소스가 다 오픈소스가 아니다.
	- 라이센스가 있는경우 고치면 법으로 걸림
	- 가져다 쓰는순간 소스코드 공개해야해 이런 것도 있음.. 잘 살펴보기
  
- ctrl f10: 한번에 결과를 볼때, 뛰어넘을때
- f5 f9 :여러번 검토해야할때 여기가 의심지역이닷!
- 파이썬 왜씀?
	- 파이썬-> 쉽다? 문법이 간결하다 
		- 쉽게, 세부적인 기능 뺀 간단히 쓸수있는 라이브러리 (전문가로 제작된 c++라이브러리랑 다름)
		- 설치후 import하면 쉽게 쓸수있다
	- 비전공자 교육용,데이터 사이언스, 자동차 스크립트
- 내가 짠코드 테스트 많이하기. 조금짜고 테스트하기 다짜고 실행하지 말고

- 리턴받을때 변수 만들어 받아준다(함수 호출 자리에 리턴값이 대체한다.)
	- 그래서 요게 된다 cout<< abc()
- 리턴은 값을 되돌려줄뿐만아니라 함수를 종료한다 도 있다
	- 그래서 void 함수에서 함수 종료할때 그냥 return;   함
- break;는 함수 한개 나가는거
	- 2중 for문이면 한개 나가기
		y랑 x가 0~4하는 이중for문인데
		y가 1이고 x가 2일때 break하는경우
		나가버려 1,3일때는 없고 y가 2,x가 0인 경우부터 계속 


11일차
- 어플리케이션 : 운영체제안에서 동작하는 프로그램
	- 윈도즈 앱 개발자
		- 마이크로소프트(c#만듬) 
		- c#이 안정적
	- 안드로이드 앱 개발자
		- 구글
		- 자바(오라클)이 구글에게 소송해서 ->코틀린으로 공식언어로 바꿈
	- ios 앱 개발자
		- 애플(스위프트)
	- 운영체제가 지원해주는 함수가 달라(win32 api)->통합 api(큐티, 자바링) 그러나 성능과 기능이 떨어짐
		- 전문적인 앱만들때는 통합 사용 x 돈많이벌려면 3분야중 하나 정해서 ㄱㄱ
- 웹어플리케이션: 웹 안에서 동작하는 프로그램
- 앱어플리케이션은 풀스택(프론트, 백엔드 모두)서버개발 할줄 알아야함