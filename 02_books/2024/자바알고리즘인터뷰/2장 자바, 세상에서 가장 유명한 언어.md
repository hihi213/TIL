- 라이브러리 풍부
- 자바이전
	- C언어가 대세
		- 절차형 프로그래밍 언어
		- 코드 복잡, 가독성 떨어져 유지보스 어려움
	- 이를 극복한것이 자바의 oop
		- 캡슐화
			- 변수와 함수를 클래스라는 단위로 묶어 따로 분리해 처리
			- 변수에 직접 접근하지 않고 메소드로 변경,조회
			- 내부에서 변수명을 바꾸는 변화가 있어도 외부 메소드는 변화가 없어 의존성이 낮다
		- 추상화
			- 적절한 추상화는 중요하지만 지나치면 코드를 이해하기 어렵다
		- 상속
		- 다형성
			- 오버로딩, 오버라이딩
	- C에 클래스개념을 도입한 C++
- 자바의 빌드와 실행
	- c++
		- 컴파일러가 소스파일을 읽어들이고 해당 운영체제에 최적화된 바이너리를 한번에 만들어냄
		- 운영체제에 따라 컴파일러가 다르기때문에 동일한 소스코드라도 다른 실행파일이 만들어지고 다르게 작동할수있다.
		- 컴파일러가 다르기 때문에 각 운영체제에 맞추어 각각 개발해야함
		- ![](02_books/2024/자바알고리즘인터뷰/그림/스크린샷%202024-07-24%20오후%207.02.34.png)
	- 자바
		- 컴파일러와 실행환경을 분리
			- 바이트코드라는 표준 중간 계층를 만듬
			- 컴파일러는 바이트코드까지만 만들고 실행환경은 각각의 운영체제에서 동작하는 방식이다. 그러므로 컴파일러는 하나만 있어도 된다.
			- 컴파일러를 개발하는게 아닌 바이트코드를 동작시키는 jre만 개발하면된다
			- ![[02_books/2024/자바알고리즘인터뷰/그림/Pasted image 20240720160109.png]]
			어떤 운영체제든 jre만 구현하면 자바의 컴파일러나 여러 도구의 이점을 그대로 활용할수있다.
	- 자바의 빌드와 실행
		1. 자바 소스 파일(java)을 자바컴파일러(javac)가 컴파일하여 바이트코드를 만든다.
		2. 각 운영체제별 jre에서 jvm을 통해 바이트코드를 운영체제에 맞게 해석하여 실행한다.
		- 어떤언어든간에 자바 바이트코드를 만들어내고 Jvm쓰면 자바처럼 wora 가능
			- ->컴파일러의 프론트엔드 역할만 구현하면 됨
			- 자이썬 : 파이썬의 jvm버전
			- 제이루비 : 루비의 jvm버전
			- 스칼라 : 위 언어들과 달리 jvm전용으로 시작
				- 학계에서 창안 순수성강조해 사용하기 어려움
			- 그루비
			- 클로저
			- 코틀린(구글의 공식언어)
				- 인텔리제이회사(젯브레인즈)에서 개발
				- 안드로이드 개발에서 자바를 대체하는 다음 세대
				- 백엔드 개발에서도 자바를 뛰어넘을것.
					- 학계에서 탄생x-> 실무문제 해결할려고 개발한 실용적인 언어
						- 현업 엔지니어들이 피드백함
						- 연구중인 주제보다 이미 성공적으로 검증된 방식을 채택하려함
						- 언어의 복잡도 낮음
						- 언어와 도구(ide)가 함께 개발됨
							- 자바는 도구없이 개발되게 설계->ide개발후 개별적으로 발전
							- 코틀린은 인텔리제이의 지원을 염두에 둠
							- 마이크로소프트가 c#과 비주얼 스튜디오를 함께 만든 예와 비슷하다 
					- 자바와의 상호운용성
						- 자바 라이브러리와 완벽히 호환
							- 자바,코틀린 섞어 작성해도 호환됨
							- 자바로 할수있는일 모두 가능
							- 반대로 자바에서도 코틀린으로 작성한 함수를 호출할수있다
					- 안전하다.
						- 언어가 안전하다
							- 언어의 구조가 개발자가 실수할 가능성을 원천적으로 방지해 오류가능성을 줄인다
								- c언어는 조금만 실수해도 메모리가 새는 프로그램... 
								- 자바에는 GC가 있어 사용하지 않는 메모리는 자동삭제해 메모리 누수를 막아줌
								- 그런 자바보다 더 안전함
							- 코틀린은 널 안정성이 이다
								- 자바의 흔한 에러인 널 포인터 예외는 컴파일 타임에 이 오류를 발견하기 쉽지 않다.
								- 제네릭을 만들어서 컴파일 타임에 오류 발견하려한것 기억남?
								- 안정적인 애플리케이션을 만들려면 런타임 오류를 최소화하고 컴파일 타임에 대부분의 오류를 잡을수있어야한다
								- 널 허용여부 구분하는 ? 가 추가됨
								- 타입뒤에 ?추가
									- 널이 될수있음
								- 타입뒤에 ?없음
									- 널이 될수없고 에러 발생
								
	- jre의 구조
		- 라이브러리
			- 자바 컬렉션 프레임워크
			- 기본 패키지
		- jvm
			- 바이트코드를 각 운영체제에 맞게 실행해주는 역할

- 코테에선 무엇을 사용하지 않는가
	- 자바는 OOP를 강조해 코드가 장황/문법 복잡
	- 대형프로젝트에는 문제가 안되지만 간결한 코테에는 불리함
	- 코테에서는 OOP 개념 보단 함수형이나 절차적인 방식으로 작성
		- 실무에서 매우 중요한 OOP는
		- 캡슐화, 추상화(복잡도 커짐),상속(재사용할만한 경우 없),다형성 쓸일이 없다
		- 실무에서 매우 중요한 접근제어자도 중요치 않다.    
		- 
			
- 코테에선 무엇을 사용하는가
	- 제네릭, 함수형 
		- 제네릭: 사용할 자료형을 명시해 컴파일 시점에 타입검사하게함
			- 에러시점: 런타임 -> 컴파일
			- List<자료형> name= new ArrayList<>();
				- 변수선언에만 타입을 기술하고 
				- 객체에는 타입선언을 생략하고 <> 형태만 기입
		- 함수형: 람다식
			- (파라미터)->내용
		- 스트림API
			1. 순회하면서 리스트에 멤버삽입
			2. 순회하면서 값을 찾기
			3. 순회하면서 정렬
			4. 순회하면서 출력
			- 이 4가지 for문을 스트림을 이용하면 한번의 과정으로 처리할수있다
			 각 요소를 한 번만 순회하면서 원하는 작업을 모두 수행할 수 있다.
		- 메소드 참조
			- 특정 메소드의 참조를 파라미터로 전달
				- 프로그래밍에서 특정 메서드(즉, 어떤 일을 하는 방법)를 다른 코드에서 사용하겠다고 가리키는 것
				-  **forEach**: 리스트의 모든 요소를 하나씩 꺼내서 주어진 작업을 반복 실행하라는 의미.
				- **::** **(메서드 참조)**: 특정 메서드를 사용하라는 의미. 람다 표현식을 더 간단하게 만드는 방법.
		- jshell
			- 결과를  실시간으로 확인할 수 있는 상호작용.
				- 터미널에 jshell만 입력하면 간단히 실행됨
				- 기본적인 패키지는 이미 임포트가 되어있다
				- 어떤결과가 나올지 모호할때 확인 가능
					- ex) 'z'-'a'
						- 25
					- 변수 선언, 출력문이 없어도 실시간으로 결과 알려줌
				- 메소드를 정의할수도 있다
					![[02_books/2024/자바알고리즘인터뷰/그림/Pasted image 20240720155131.png]]
				- 명령어들
					- /methods
						정의한 메소드 확인
					- /vars
						정의한 변수 확인
					- /list
						입력했던 코드 확인
					- /types
						정의한 타입(클래스,인터페이스 등)확인
					- /imports
						임포트 패키지 확인
				- tab 누르면 자동완성해준다
