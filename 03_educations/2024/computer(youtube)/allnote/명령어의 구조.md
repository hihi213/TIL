- 저급언어는 명령어들로 이루어져 있는데, 명령어 하나하나는 어떻게 생겼고 동작할까?
	
	- 명령어의 구조
		- 명령어는 동작과 대상으로 이루어져 있다.
				ㅇㅇ아 ~를 해라
			- 더해라 100과 10를
			- 빼라 메모리 32번지 안의 값과 메모리 33번지 안의 값을
			- 저장해라 10을 메모리 128번지에 
		- 즉 수행할 연산과 연산에 사용될 데이터 /위치 (연산에 사용될 데이터가 저장된)를 포함한다.
		
		- 명령어는 연산코드와 오퍼랜드로 이루어져있다.
			- 어셈블리어와 기계어는 명령어로 이루어져 있다
			- == 어셈블리어는 연산코드와 오퍼랜드로 이루어져 있다
			- 오퍼랜드란?
				1.  연산에 사용될 데이터
				2.  **주소필드**(메모리에 저장된 데이터의 위치를 가리킴)
					-  **명령어 크기의 제한**:
						명령어의 크기를 16비트라고 가정합니다.
						연산 코드가 4비트라고 가정하면, 나머지 12비트가 오퍼랜드(연산에 사용되는 데이터) 표현에 사용됩니다.
						12비트는 최대 2^12(4096)개의 값을 표현할 수 있습니다.
					-  **데이터 크기의 제한**:
						2-오퍼랜드 구조에서는 오퍼랜드 하나당 6비트가 사용됩니다.
						따라서, 각 오퍼랜드는 최대 2^6(64)개의 값만 표현할 수 있습니다.
						오퍼랜드의 개수가 많아지면, 각 오퍼랜드에 할당되는 비트 수는 더 줄어듭니다.
					-  **메모리 주소의 활용**:
						메모리 주소를 이용하면 오퍼랜드 하나를 주소 필드의 데이터로 확장할 수 있습니다.
						즉, 명령어가 직접 데이터 값을 포함하는 대신, 데이터가 저장된 메모리 위치(주소)를 포함하여 더 큰 데이터 공간을 활용할 수 있습니다.
					이를 통해 명령어의 크기 제한을 극복하고 더 많은 데이터를 처리할 수 있습니다.
				- 유효주소(접근이 가능한 주소필드)
				- 명령어 주소지정방식
					- 유효주소를 찾는 방법
					- 방식은 다양하다 방식만 알면 명령어를 보고 어디에 저장되어 있구나 알수있음(cpu마다 차이가 있음
						- 메모리에 주소지정하는 방식
							- 즉시 주소지정방식
								- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
								- 유효주소x(데이터 자체가 명령어에 있음 )
								- 연산에 사용될 데이터의 크기가 제한되지만 빠름
							- 직접 주소 지정방식
								- 유효주소를 오퍼랜드 필드에 직접 명시
								- 유효주소의 크기가 제한됨(연산코드크기와 반비례)
							- 간접 주소 지정방식
								- 유효주소의 주소를 오퍼랜드 필드에 명시
								- 속도가 느림
									- cpu가 메모리 뒤지는 시간은 매우느림
									- cpu 메모리 접근을 최소화해야함(중요)
						- 이외 방식
							- 레지스터 주소지정방식
								- 연산에 사용될 데이터가 저장된 레지스터 명시
								- cpu는 메모리 접근속도보다 레지스터 접근속도가 훨씬 빠름(매우 중요)
							- 레지스터 간접주소지정방식
								- 연산에 사용될 데이터는 메모리에 저장
								- 그 주소를 레지스터에 저장
								- 그 레지스터의 주소를 오퍼랜드 필드에 명시
			- 오퍼랜드는 없는 경우도 있고 하나 이상인 경우도 있다.
				![](03_educations/2024/computer(youtube)/picture/6.26.48.png)
			- 연산코드
				- 수행할 연산
			- 연산코드의 종류와 생김새는 [cpu마다 다르다](03_educations/2024/computer(youtube)/allnote/레지스터(챗지피티)_강민철추가자료.md).
				- 공통적인 연산코드의 개수(유형만 기억 cpu마다 다름)
					1. 데이터 전송 	
						- 데이터를 옮겨라(move)
						- 메모리에 저장하라(store)
						- 메모리에서 cpu로 데이터를 가져와라(load(fetch))
						- [스택](03_educations/2024/computer(youtube)/allnote/자료구조.md)에 데이터를 저장하라(push)
						- 스택의 최상단 데이터를 가져와라(pop)
					3. 산술/논리 연산
						- 덧셈/뺄셈/곱셈/나눗셈를 수행하라
							ADD/ SUBTRACT/ MULTPLY/ DIVIDE
						- 오퍼랜드에 1를 더해라/ 오퍼랜드에 1를 빼라
							INCREMENT/ DECREMENT
						- AND/ OR/ NOT 연산을 수행하라
						- 두개의 숫자 또는 논리값(true/ false)을 비교해라
							COMPARE
					3. 제어 흐름 변경
						- 특정 주소로 실행 순서를 옮겨라
							JUMP
							• **예시**: 현재 실행 중인 코드에서 100번째 줄로 바로 가라는 의미입니다. 
							• **사용 상황**: 코드의 특정 부분을 건너뛰거나, 루프를 만들 때 사용됩니다.
						- 조건이 부합할때 특정주소로 실행순서를 옮겨라
							CONDITIONAL JUMP
							• **예시**: 변수 x가 0보다 클 때 200번째 줄로 가라는 의미입니다.
							• **사용 상황**: 조건문 (if 문)처럼 특정 조건에 따라 코드의 흐름을 바꿀 때 사용됩니다.
						- 프로그램의 실행을 멈춰라
							HALT
							• **예시**: 프로그램이 종료되어 더 이상 아무 것도 하지 않도록 합니다.
							• **사용 상황**: 프로그램이 끝났을 때나 더 이상 실행할 코드가 없을 때 사용됩니다.
						- 되돌아올 주소를 저장한채 특정주소로 실행순서를 옮겨라
							CALL
							• **예시**: 현재 실행 중인 위치를 기억하고 함수나 서브루틴의 시작 위치로 가라는 의미입니다.
							• **사용 상황**: 함수 호출 시 사용됩니다. 호출한 함수가 끝나면 원래 위치로 돌아가야 하기 때문에 CALL을 사용합니다.
						- call를 호출할때 저장했던(되돌아올) 주소로 돌아가라
							RETURN
							• **예시**: 함수나 서브루틴의 실행이 끝나면, CALL 명령어가 실행되기 전의 위치로 돌아갑니다.
							• **사용 상황**: 함수나 서브루틴이 끝났을 때, 원래의 코드 위치로 돌아갈 때 사용됩니다.
					4. 입출력 제어
						- 특정 입출력 장치로부터 데이터를 읽어라
							- READ(INPUT)
						- 특정 입출력 장치로 데이터를 써라
							- WRITE(OUTPUT)
						- 입출력 장치를 시작하라
							- START IO
						- 입출력 장치의 상태를 확인하라
							- TEST IO

