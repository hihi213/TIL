### 명령어가 어떻게 생겨야 명령어 파이프라이닝에 유리할까?
- 명령어가 실행되여야하는 하나의 시간이 비교적 정형화 되어있어야 한다
	- 명령어의 길이나 실행시간이 일정해야 한다
	- 
#### cpu는 cpu마다 서로 다른 명령어를 실행한다.
- 명령어의 세세한 생김새, 연산, 주소 지정 방식등은 cpu마다 다르다
- 즉 각 cpu는 명령어 집합에 속해 있는 명령어들만 이해할 수가 있다.
	- 인텔 cpu컴퓨터에서 만든 실행 파일을 그대로 아이폰에 옮겨 특정한 설정없이 그 exe 실행파일을 실행하면 실행이 안된다
	- 명령어 집합
		- cpu가 이해할 수 있는 명령어들의 모음
			- 인텔의 cpu : x86 명령어 집합
			- 애플의 cpu : ARM 명령어 집합
- 즉 cpu마다 이해하는 명령어의 종류가 다르다
- 즉 같은 소스 코드를 컴파일 할지라도 어셈블리어, 기계어의 종류가 cpu마다 다르다


### 명령어가 달라지면 나비효과로 많은것들이 달라진다 
- 명령어 해석방식, 레지스터의 종류와 개수., 파이프라이닝의 난이도 등
- 그렇기 때문에 명령어 집합에 따라 cpu의 구조, 컴퓨터의 구조까지 결정이 된다.
	- 그래서 명령어 집합 구조(Instruction Set Architecture)라고 부르기도 한다
	- ISA는 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이다. 
		- 명령어 집합이 다르면 그 명령어를 효율적으로 실행할 수 있는 하드웨어 구조도 달라지기 때문에 아 이런 명령어가 동작하기 편하게 만들어야겠군 하고 이해하는 

### 현대의 대표적인 명령어 집합의 두종류 CISC/ RISC
- CISC(Complex Instruction Set Computer)
	- 복잡한 명령어 집합을 활용하는 컴퓨터(cpu)
		- 가변길이 명령어를 활용한다.(명령어의 크기와 형태가 다양하다)
		- 명령어 종류가 다양하다
			- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 가 있다.
		- 메모리를 최대한 아끼던 시절에 인기가 높았지만
		- 명령어 파이프라이닝이 불리한 치명적인 단점이 있다
			- 하나의 명령어 실행하는데 여러 클럭 주기 필요
				- 명령어의 개별적 크기와 실행되기까지 시간이 일정하지 않음
				- 대다수의 명령어는 사용빈도가 낮다
	- x86 / x86-64의 기반이다.
- RISC(Reduced Instruction Set Computer)
	