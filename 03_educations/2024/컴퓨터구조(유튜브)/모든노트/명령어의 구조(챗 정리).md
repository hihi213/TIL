
저급 언어는 명령어들로 이루어져 있는데, 명령어 하나하나는 어떻게 생겼고 동작할까?

### 명령어의 구조
명령어는 동작과 대상으로 이루어져 있다.

- ㅇㅇ아 ~를 해라
    - 더해라 100과 10을
    - 빼라 메모리 32번지 안의 값과 메모리 33번지 안의 값을
    - 저장해라 10을 메모리 128번지에

즉, 수행할 연산과 연산에 사용될 데이터/위치(연산에 사용될 데이터가 저장된 위치)를 포함한다.

명령어는 연산코드와 오퍼랜드로 이루어져 있다.
- 어셈블리어와 기계어는 명령어로 이루어져 있다.
- 어셈블리어는 연산코드와 오퍼랜드로 이루어져 있다.

### 오퍼랜드란?
연산에 사용될 데이터를 말한다.

**주소 필드**(메모리에 저장된 데이터의 위치를 가리킴)
- **명령어 크기의 제한**:
    명령어의 크기를 16비트라고 가정하면, 연산코드가 4비트인 경우 나머지 12비트가 오퍼랜드(연산에 사용되는 데이터) 표현에 사용된다. 12비트는 최대 2^12(4096)개의 값을 표현할 수 있다.
- **데이터 크기의 제한**:
    2-오퍼랜드 구조에서는 오퍼랜드 하나당 6비트가 사용된다. 따라서, 각 오퍼랜드는 최대 2^6(64)개의 값만 표현할 수 있다. 오퍼랜드의 개수가 많아지면 각 오퍼랜드에 할당되는 비트 수는 더 줄어든다.
- **메모리 주소의 활용**:
    메모리 주소를 이용하면 오퍼랜드 하나를 주소 필드의 데이터로 확장할 수 있다. 즉, 명령어가 직접 데이터 값을 포함하는 대신, 데이터가 저장된 메모리 위치(주소)를 포함하여 더 큰 데이터 공간을 활용할 수 있다. 이를 통해 명령어의 크기 제한을 극복하고 더 많은 데이터를 처리할 수 있다.

### 유효 주소
접근이 가능한 주소 필드를 말한다.

### 명령어 주소 지정 방식
유효 주소를 찾는 방법이다. 방식은 다양하며, 방식만 알면 명령어를 보고 어디에 저장되어 있는지 알 수 있다(CPU마다 차이가 있음).

- 메모리에 주소 지정하는 방식
    - 즉시 주소 지정 방식
        - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
        - 유효 주소 없음 (데이터 자체가 명령어에 있음)
        - 연산에 사용될 데이터의 크기가 제한되지만 빠름
    - 직접 주소 지정 방식
        - 유효 주소를 오퍼랜드 필드에 직접 명시
        - 유효 주소의 크기가 제한됨(연산 코드 크기와 반비례)
    - 간접 주소 지정 방식
        - 유효 주소의 주소를 오퍼랜드 필드에 명시
        - 속도가 느림
        - CPU가 메모리를 탐색하는 시간은 매우 느림
        - CPU 메모리 접근을 최소화해야 함(중요)

- 기타 방식
    - 레지스터 주소 지정 방식
        - 연산에 사용될 데이터가 저장된 레지스터를 명시
        - CPU는 메모리 접근 속도보다 레지스터 접근 속도가 훨씬 빠름(매우 중요)
    - 레지스터 간접 주소 지정 방식
        - 연산에 사용될 데이터는 메모리에 저장
        - 그 주소를 레지스터에 저장
        - 그 레지스터의 주소를 오퍼랜드 필드에 명시

오퍼랜드는 없는 경우도 있고 하나 이상인 경우도 있다.

### 연산코드
수행할 연산을 나타낸다. 연산코드의 종류와 생김새는 CPU마다 다르다.

- 공통적인 연산코드의 유형
    1. 데이터 전송
        - 데이터를 옮겨라 (move)
        - 메모리에 저장하라 (store)
        - 메모리에서 CPU로 데이터를 가져와라 (load(fetch))
        - 스택에 데이터를 저장하라 (push)
        - 스택의 최상단 데이터를 가져와라 (pop)
    2. 산술/논리 연산
        - 덧셈/뺄셈/곱셈/나눗셈을 수행하라 (ADD/SUBTRACT/MULTIPLY/DIVIDE)
        - 오퍼랜드에 1을 더해라 / 오퍼랜드에 1을 빼라 (INCREMENT/DECREMENT)
        - AND/OR/NOT 연산을 수행하라
        - 두 개의 숫자 또는 논리값(true/false)을 비교하라 (COMPARE)
    3. 제어 흐름 변경
        - 특정 주소로 실행 순서를 옮겨라 (JUMP)
            - 예시: 현재 실행 중인 코드에서 100번째 줄로 바로 가라는 의미이다.
            - 사용 상황: 코드의 특정 부분을 건너뛰거나, 루프를 만들 때 사용된다.
        - 조건이 부합할 때 특정 주소로 실행 순서를 옮겨라 (CONDITIONAL JUMP)
            - 예시: 변수 x가 0보다 클 때 200번째 줄로 가라는 의미이다.
            - 사용 상황: 조건문(if 문)처럼 특정 조건에 따라 코드의 흐름을 바꿀 때 사용된다.
        - 프로그램의 실행을 멈춰라 (HALT)
            - 예시: 프로그램이 종료되어 더 이상 아무 것도 하지 않도록 한다.
            - 사용 상황: 프로그램이 끝났을 때나 더 이상 실행할 코드가 없을 때 사용된다.
        - 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 (CALL)
            - 예시: 현재 실행 중인 위치를 기억하고 함수나 서브루틴의 시작 위치로 가라는 의미이다.
            - 사용 상황: 함수 호출 시 사용된다. 호출한 함수가 끝나면 원래 위치로 돌아가야 하기 때문에 CALL을 사용한다.
        - CALL을 호출할 때 저장했던(되돌아올) 주소로 돌아가라 (RETURN)
            - 예시: 함수나 서브루틴의 실행이 끝나면, CALL 명령어가 실행되기 전의 위치로 돌아간다.
            - 사용 상황: 함수나 서브루틴이 끝났을 때, 원래의 코드 위치로 돌아갈 때 사용된다.
    4. 입출력 제어
        - 특정 입출력 장치로부터 데이터를 읽어라 (READ(INPUT))
        - 특정 입출력 장치로 데이터를 써라 (WRITE(OUTPUT))
        - 입출력 장치를 시작하라 (START IO)
        - 입출력 장치의 상태를 확인하라 (TEST IO)