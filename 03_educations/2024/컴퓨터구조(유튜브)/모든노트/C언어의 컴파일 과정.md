
- 보통 c언어에서 컴파일하면 1->4로 빠르게 되기에 내부과정을 모르는데 내부과정은 이렇다
1. **전처리기 (Preprocessor)**: 코드 준비 작업 (헤더 파일 포함, 매크로 변환 등)
2. **컴파일러 (Compiler)**: 소스 코드를 어셈블리어로 변환
3. **어셈블러 (Assembler)**: 어셈블리어를 기계어(목적 코드)로 변환하여 목적 파일 생성
4. **링커 (Linker)**: 여러 목적 파일을 하나의 실행 파일로 결합
## 소스코드(test.c)는
## 1. 전처리기 를 거쳐 (test.i)가 되고
- #### 전처리과정(preprocesssing)
	- 컴파일하기 전의 준비 작업.
		- 헤더파일을 소스파일에 포함시킨다.
			- 소스파일에서 필요로하는(#include라고 명시된 외부파일) 외부파일과 라이브러리 소스파일에 포함시킨다.
		- 매크로 변환
			- 코드 짧게 쓰는 약속인 매크로를 원래 코드로 되돌려놓는다.
		- 조건부 컴파일 지시어 따라 코드를 포함시키거나 제거한다.
			- 전처리 지시어를 사용하여 특정 조건에 따라 코드를 포함시키거나 제거할 수 있어요. 예를 들어, 디버깅할 때만 필요한 코드를 컴파일할 때만 포함시키고, 릴리즈 버전에서는 제외할 수 있어요.
## 2. 컴파일러 를 거쳐 (test.s)가 되고
- #### 컴파일과정(compiling)
	- 전처리가 완료되어도 여전히 소스코드이다.
	- 전처리 완료된 소스코드 -> 저급언어(어셈블리 언어)로 변환해야함
## 3. 어셈블러 를 거쳐 (test.o)가 되고
- #### 어셈블과정(assembling)
	- 왜 어셈블리어를 거쳐서 기계어로 바꾸나?
		- 어셈블리 언어는 CPU 아키텍처에 종속적입니다. 따라서, 컴파일러가 다양한 CPU 아키텍처를 지원하기 위해 어셈블리 언어를 거쳐서 기계어로 변환하는 것이 유리합니다.
		- • 소스 코드를 직접 기계어로 변환하는 것은 매우 복잡하고 오류가 발생하기 쉽습니다.
		- • 중간 단계인 어셈블리 언어로 변환하면, 변환 과정을 더 잘 이해하고 디버깅하기가 쉬워집니다.
	- 어셈블리어->기계어(목적코드)로 변환 
		- 목적코드를 포함하는 목적 파일이됨
	- 목적파일?
		- 목적파일과 실행파일은 둘다 기계어로 이루어진 파일
		- 그러나 목적파일은 완전한 실행파일이 아니고 링킹과정을 통해 실행파일이 된다
## 4. 링커 를 거쳐  (test.exe)가 된다
- #### 링킹(linking)
	- 각기 다른 여러 목적파일을 하나의 실행파일로 결합시키는것
	- 전처리 과정에서 #include 지시어를 통해 헤더 파일을 포함시키는 작업이 있지만, 실제 라이브러리 코드와의 결합은 링킹 단계에서 이루어집니다.
