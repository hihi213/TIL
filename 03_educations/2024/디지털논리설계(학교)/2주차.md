# 우리가 배울것
- 보수가 무엇인가?
- 왜 보수가 효율적인가?

- 디지털시스템이란?
	- 이산적인(discrete) 입력 집합을 받고 내부 상태를 가져와 이산적인 출력 집합을 생성하는 시스템
		- 이산적인 : 연속x, 개별적인
		- 내부상태 : 시스템의 현재 상황(시작,실행...이산적인 상태)
	- 이산적인 입력와 내부상태를 사용하여 출력과 다음 상태를 결정하는 디지털회로로 구성된다.
- 디지털시스템은 2가지로 나뉜다
	1. 조합논리시스템(중간)
		- 현재의 출력은 현재의 입력에만 의해 결정
	2. 순차논리시스템(기말)
		- 입력과 현재상태에 따라 출력과 다음상태를 결정
		- 이때 과거 정보를 저장하는방법=메모리
		- 종류
			1) 동기식 순차 시스템
				- 클록신호에 의해 제어
			2) 비동기식 순차 시스템
				- 입력이 변할때 즉각적으로 상태가 변함
				- 상태와 입력에의해 다음상태와 출력이 결정
				- 약속을 정하지 않아 핸드쉐이킹해야함
					- 큰회로는 부담이되서 동기식을 사용한다
- Signal
	- 디지털 시스템에서 정보의 이산적 요소는 *신호* 라는 이산적인 물리량으로 표현
	- 디지털 시스템에서 *변수*는 이산적인 값을 갖음
	- 이진값(*binary value*)은 디지털 시스템에서 가장 널리 사용
		- 0/1
		- T/F
		- Low/High
		- On/Off
	- ![](../../../01_daily_study/pic/Pasted%20image%2020240903134514.png)
## 1과 0을 어떻게 표현할 것인가

- 디지털 신호의 전압(Voltage)
	- 전압이란?
		- 두 지점 사이의 전위 차이
		- 참고
			- 전류는 시간당 흐르는 전자의 양
			- 전류!=전압
			- 전류는 전압이 존재할때만 흐름
	- output(보낼때)
		- 1: high(4v~5v)
		- 0: low(0v~1v)
	- input(받을때)
		- 1: high(3v~5v)
		- 0: low(0v~2v)
		- 전달될때 노이즈에 영향받기에 output과 input은 1v 노이즈마진 차이까지는 감안함
	- 전압이 높으면 발열 때문에 전압을 최대한 줄인게 5v->1v
		- 노이즈 마진도 1v-> 0.2v로 줄어듬
		- 오작동 범위 넓어짐 그래서 전압을 줄이는데 한계가 있다
- Binary Values(0과 1를 표현하는 다른 물리량)
	- cpu : voltage(전압)
	- Disk : Magnetic Field Direction(자화방향)
	- CD : Surface Pits/Light(홈을 파서 빛의 굴절의 정도)
	- Dynamic Ram: Electrical Charge(Electrical 있으면 1)
		-  **DRAM**은 전하를 저장하는 메모리로, 시간이 지나면 자연스럽게 전하가 방전되어 데이터 손실이 발생할 수 있습니다.
		-  외부 요인, 예를 들어 **입자 충돌**이나 **방사선** 등의 영향으로 데이터가 변경될 수도 있습니다.
		-  이러한 문제를 해결하기 위해 **리프레시(Refresh)** 과정이 필요하며, 주기적으로 데이터를 읽고 다시 쓰는 방식으로 데이터를 유지합니다.
		- 또한, **에러 정정 코드(ECC)**를 통해 오류가 발생했을 때 이를 감지하고 복구할 수 있습니다.
## 수를 어떻게 1과 0으로 표현할 것인가?
- 기수(radix): 진법
	- 10진수는 기수가 10
- DIgits(한자리에 표현 가능한 숫자)
	- 8진수는 디지트가 0,1,2,3,4,5,6,7
	- 2진수가 디지트가 비트 0,1
- 우리는 계수들로 보기쉽게 표시한다(기수생략)
	- 465
		- 10진수일경우 실제 의미
			- 4 * 10^2 + 6 * 10^1 +5 * 10^0
		- 8진수일경우 실제 의미
			 4 * 8^2 + 6 * 8^1 +5 * 8^0
		- 2진수일경우 실제 의미
			 4 * 2^2 + 6 * 2^1 +5 * 2^
	- 즉 계수 * 기수의 거듭제곱의 합이다 
- 바이트 단위
	- 8bits
		1byte(바이트)
	- 2^10
		KB= 1024B (킬로바이트)
	- 2^20
		MB=1,048,576B (메가바이트 약 백사만바이트)
	- 2^30
		GB= 1,073,741,824(기가바이트 약 십억바이트(>10^9))
	- TB(2^40) -> PB (2^50)
- 우리는 2진수를 사용한다 
	- <변환>
		- 10진수를 2진수로 바꾸는법(소수)
		- 2진수를 10진수로 바꾸는법
		- 8진수를 2진수로 바꾸는법 (소수)
		- 2진수를 8진수로 바꾸는법(소수)
- 사용자는 가독성을위해 8진수, 16진수를 사용한다
	- 메모리 주소표현, 파일권한, 디버깅, 컬러코드
	- 컴퓨터의 소통에서 인간은 10진수,16진수,8진수 등을 사용하지만 컴퓨터는 항상 2진수로 처리한다
	- 8진수는 3bit, 16진수는 4bit
	- <변환>
		- 8진수(소수포함)-> 십진수 변환
		- 10진수->8진수(소수)
		- 16진수(소수포함)-> 십진수 변환
		- 2진수(소수포함)-> 16진수 변환
		- 16진수(소수포함)-> 2진수로 변환
			1.	정수 변환법:
				•	정수 변환 시 각 자릿수에 해당 진법의 거듭제곱을 곱해 변환합니다.
				•	예:  12.34(8진수) 에서 정수 부분은  1 \times 8^1 + 2 \times 8^0 = 10(10진수) 
			2.	소수 변환법:
				•	소수 변환 시 각 자릿수에 해당 진법의 음수 거듭제곱을 곱해 변환합니다.
				•	예:  0.34(8진수) 에서 소수 부분은  3 \times 8^{-1} + 4 \times 8^{-2} = 0.4375(10진수) 

- 10진수로 만들때  각자리에 진수 거듭제곱 곱한후 합산
- 10진수가 다른진수가 될때 : 다른진수로 나눈 나머지 소수는 진수를 곱한 값
- 8,2,16끼리 변환 : 한자리를 3자리혹은 4자리 변환

| 변환 종류                  | 정수 부분 변환법                                   | 소수 부분 변환법                                     | 예시 변환 결과(정수)                                                                                                                      |                                                                                  |
| ---------------------- | ------------------------------------------- | --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **2진수 → 10진수**         | 각 자리에 2의 거듭제곱을 곱한 후 합산                      | 각 자리에 2의 음수 거듭제곱을 곱해 합산                       | **1010.01(2) → 10.25(10)**<br>① 정수: \(1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 8 + 0 + 2 + 0 = 10\)<br>        | ② 소수: \(0 \times 2^{-1} + 1 \times 2^{-2} = 0.25\)                               |
| **8진수(소수 포함) → 10진수**  | 각 자리에 8의 거듭제곱을 곱하기                          | 각 자리에 8의 음수 거듭제곱을 곱하기                         | **12.34(8) → 10.4375(10)**<br>① 정수: \(1 \times 8^1 + 2 \times 8^0 = 8 + 2 = 10 \)<br>                                             | ② 소수: \(3 \times 8^{-1} + 4 \times 8^{-2} = 0.375 + 0.0625 = 0.4375\)            |
| **16진수(소수 포함) → 10진수** | 각 자리에 16의 거듭제곱을 곱하기                         | 각 자리에 16의 음수 거듭제곱을 곱하기                        | **A.1C(16) → 10.109375(10)**<br>① 정수: \(A(10) \times 16^0 = 10 \)<br>                                                             | ② 소수: \(1 \times 16^{-1} + C(12) \times 16^{-2} = 0.0625 + 0.046875 = 0.109375\) |
| **8진수 → 2진수**          | 8진수의 각 자리를 3자리의 2진수로 변환 (2³, 2², 2¹, 2⁰ 기준) | 소수 부분은 각 자릿수를 3자리의 2진수로 변환                    | **25.4(8) → 10101.100(2)**<br>① 정수: 2(8) → 010(2), 5(8) → 101(2)<br>                                                              | ② 소수: 4(8) → 100(2)                                                              |
| **10진수 → 2진수**         | 10진수를 2로 나눈 나머지를 기록 후 역순으로 나열               | 소수 부분은 10진수 소수에 2의 음수 거듭제곱을 곱한 후, 결과를 2진수로 변환 | **10.25(10) → 1010.01(2)**<br>① 정수: 10 ÷ 2 = 5, 나머지 0<br>5 ÷ 2 = 2, 나머지 1<br>2 ÷ 2 = 1, 나머지 0<br>1 ÷ 2 = 0, 나머지 1<br>결과: 1010<br> | ② 소수: 0.25 × 2 = 0.5 (0), 0.5 × 2 = 1 (1) → 0.01(2)                              |
| **10진수 → 8진수**         | 10진수를 8로 나눈 나머지를 역순으로 나열                    | 소수 부분은 10진수 소수에 8의 음수 거듭제곱을 곱한 후, 결과를 8진수로 변환 | **153.75(10) → 231.6(8)**<br>① 정수: 153 ÷ 8 = 19, 나머지 1<br>19 ÷ 8 = 2, 나머지 3<br>2 ÷ 8 = 0, 나머지 2<br>결과: 231(8)<br>                 | ② 소수: 0.75 × 8 = 6                                                               |
| **16진수(소수 포함) → 2진수**  | 각 자리를 4자리의 2진수로 변환                          | 각 자리를 4자리의 2진수로 변환                            | **C.9(16) → 1100.1001(2)**<br>① 정수: C(16) → 1100(2)<br>                                                                           | ② 소수: 9(16) → 1001(2)                                                            |
| **2진수 → 8진수**          | 2진수를 3자리씩 묶어서 2의 거듭제곱을 곱한 후 합산해 8진수로 변환     | 소수 부분은 2진수를 3자리씩 묶어 8진수로 변환                   | **101010.101(2) → 52.5(8)**<br>① 정수: 101010(2) → 52(8)<br>                                                                        | ② 소수: 101(2) → 5(8)                                                              |
| **2진수(소수 포함) → 16진수**  | 4자리씩 묶어 16진수로 변환                            | 4자리씩 묶어 16진수로 변환 (부족한 자리 0으로 채우기)             | **1011.101(2) → B.A(16)**<br>① 정수: 1011(2) → B(16)<br>                                                                            | ② 소수: 101(2) → A(16) (3자리이므로 0을 추가하여 1010으로 변환)                                  |
- 현실세계의 10진수는 항상 2진수로 변환할수 없다
	- 0.65는 0.101001.......반복
	- 소숫점자리는 근사치를 사용

# 퀴즈
- 다음 각 연산이 올바르기 위한 숫자의 기수를 결정
	- 15 * 3=51
		- (b + 5) * 3 = (b * 5)+1
		- b=7, 7진수
- 2차방정식 x^2 -13x +22= 0의 해는 십진수로 2와 7이다 이때 방정식이 성립하는 기수는?
	- n진수 13== 9
		- 1 * b+ 3= 9
			b=6
	- n진수 22== 14
		- 2 * b+ 2=14
			b=6
	- 즉 6진법
- 10진수 45.125를 2진수로 변환
	- 정수 101101
		- 45/2 = 22..1
		- 22/2= 11.. 0
		- 11/2= 5...1
		- 5/2=2...1
		- 2/2= 1..0
		- 1/2=0..1
	- 소수  0.001
		- 0.125 * 2 =0.25 (0)
		- 0.25 * 2 = 0.5 (0)
		- 0.5 * 2 = 1.0 (1)
	- 101101.001
- 십진수 3.33의 2진수와의 오차 백분율을 구해라
	1) 10진수 3.33과 등가인 2진수를 4자리까지 계산하고
		- 정수 11
			- 3/2= 1..1
			- 1/2= 0...1
		- 소수 0.0101
			- 0.33 * 2 = 0.66 (0)
			- 0.66 * 2 = 1.32 (1)
			- 0.32 * 2 = 0.64(0)
			- 0.64 * 2 = 1.28(1)
		- 즉 11.0101
	2) 계산된 2진수를 10진수로 변환하고
		- 정수 3
			- 1 * 2^1 + 1 * 2^0 =3
		- 소수
			- 1* 2^-2 + 1 * 2^-4 = 0.25+ 0.0625= 0.3125
		- 즉 3.3125
	3) 두수의 오차백분률를 구한다
		- (3.33- 3.3125)/3.33 * 100 = 0.526%

## 보수
- 어떤 수에서 더했을 때 **그 수의 기수에 따라 가장 큰 값**이 되는 수
- 보수법: 빼는 뺄셈을 , 보수를 더하는 방식으로 해결하는 방법.
1. 양수를 음수로 바꾸는게 2의보수 이것만 기억하자
2.  1의 보수는 2의보수구하는 과정이라고 생각하고 
	- 1의 보수를 사용하면 **+0과 -0이 존재하는 문제**가 발생
	- ​1.	(r-1)의 보수:
		- 각 자릿수의 최대값에서 그 자릿수의 숫자를 뺀값
			- 이때의 최대값: 기수-1 
			- 그 자릿수에 해당하는 숫자 : N 
			- (r -1)-N
		- 이걸 정확히 표현하면 (r^자리수 -1) -N
			- 예: 10진수 365에서 9의 보수
				- (1000-1)-365
				- 999-365 이 값이 r-1의 보수
			- 예: 8진수 45003의 7의 보수?
				- (100000-1)-45003
				- 77777-45003
	2.	r의 보수:
		- r-1 의 보수값에 1을 더하기만 한 값입니다. 
			- 예: 10진수에서 365 보수
			- (999-365)+1 
		- 2진수 보수법 쉽게 계산하는법
			- 끝에서부터 처음으로 1이 나온 다음부터 뒤집는다
			- 101010
			- 010110
		- r-1 의 보수를 구하면서 뺄셈이 들어가지만 궁극적으론 이 과정을 통해 뺄셈을 덧셈으로 바꾸는게 목표
		- 이때 2진수는 비트 반전한값+1로 2의 보수를 구할 수 있으므로 보수를 구할때도 뺄셈을 쓰지 않는다
			- 컴퓨터는 2진수다 그리고 덧셈회로만 있다. 그것만으로 2의 보수를 구한다.
			- 예: 555-365
				- 555+(10진수에서 365 10의 보수)
				- 555+ 635 = 1190
				- 여기서 1000을 무시하면 119 올바른 값이 나온다
				- 식으로 표현하면
					- M+{2^n -N}= M-N+2^n
		- 2의 보수를 활용한 뺄셈
			1)  M >=  N일 경우 (캐리 발생함)
				1) {M+(N의 보수)}의 값의 캐리 버린게 결과값
			2) M < N일 경우 (캐리 발생 안함) 
				1) {M+(N의 보수)}의 2의 보수값에다가 전체 마이너스 붙인게 결과값
				- {M+(N의 보수)}은 둘 사이의 차이만 구한거니까 2의 보수를 취해 음수로 바꾼다.                                      
				- 마이너스를 추가로 붙이는 이유
					- 2의 보수를 취하면 그 값은 이미 음수를 나타냄.
					- 하지만 **수학적 표현에서 음수는 ‘부호’를 명확히 하기 위해** 마이너스를 붙이는 것.
					-  따라서, 컴퓨터가 계산한 결과를 우리가 음수로 인식하고자 할 때, **마이너스를 붙여서 ‘결과는 음수다’라는 의미를 명확히 하기 위한 과정**이야.

### 4비트 양수와 음수 비교 (1의 보수 vs 2의 보수)

|  10진수  |  양수(2진수)  |  1의 보수(음수)  |  2의 보수(음수)  |
|:--------:|:--------------:|:----------------:|:----------------:|
|   +0     |      0000      |      1111 (-0)   |      0000        |
|   +1     |      0001      |      1110 (-1)   |      1111        |
|   +2     |      0010      |      1101 (-2)   |      1110        |
|   +3     |      0011      |      1100 (-3)   |      1101        |
|   +4     |      0100      |      1011 (-4)   |      1100        |
|   +5     |      0101      |      1010 (-5)   |      1011        |
|   +6     |      0110      |      1001 (-6)   |      1010        |
|   +7     |      0111      |      1000 (-7)   |      1001        |
|   -0     |      -         |      1111 (-0)   |      -           |
|   -1     |      -         |      1110 (-1)   |      1111        |
|   -2     |      -         |      1101 (-2)   |      1110        |
|   -3     |      -         |      1100 (-3)   |      1101        |
|   -4     |      -         |      1011 (-4)   |      1100        |
|   -5     |      -         |      1010 (-5)   |      1011        |
|   -6     |      -         |      1001 (-6)   |      1010        |
|   -7     |      -         |      1000 (-7)   |      1001        |
|   -8     |      -         |      -           |      1000        |
	 
### 차이점 요약
- **1의 보수 방식**은 양수의 **비트를 반전**시켜 음수를 표현하며, **+0과 -0이 모두 존재**하는 단점이 있습니다.
- **2의 보수 방식**은 양수의 1의 보수에 **1을 더한 값**으로 음수를 표현하고, **0은 오직 하나**로 나타납니다.
- **2의 보수 방식**에서는 **-8**까지 표현할 수 있으며, 이는 4비트로 표현할 수 있는 가장 작은 음수입니다.

이 표를 통해 1의 보수와 2의 보수 방식의 차이점과 음수 표현 방식을 쉽게 비교할 수 있습니다.