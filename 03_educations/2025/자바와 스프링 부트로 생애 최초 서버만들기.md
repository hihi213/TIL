## \<GPT와 고민>
- ### 단축키 정리
	- 키의 의미
		- command: 명령의 중심
			- 가장 전역적
			- 사용자의 행동을 명령처럼 내릴때
		- control: 제어, 보조기능, 콘솔스타일 조작
			- 커서그대로 화면조작
			- 행단위
		- option: 선택지, 세부조정
			- 세밀조작에서 등장
			- 단어단위, 다중선택, 경로설정
		- fn: 방향/기능 보조
			- fn+지우기=>Delete 역할
	- 키암기팁
		- command: 전체, 전역
			- command+ 방향키: 그방향끝으로 점프
			- command+ 지우기: 줄 전체 삭제
		- control: 화면조작/ 줄
		- option: 단어단위조작
		- fn: 방향/기능 보조
	- 인텔리제이
		- command클릭/command+B: 실제코드 들어가기
		- 파일 검색 단축키: command+shift+o 
	- 캡쳐
		- control +shift+ cmd+ 4: 선택한영역을 클립보드에 복사 control없으면 파일형태로 저장
		- control +shift+ cmd+ 3: 화면을 클립보드에 복사 control없으면 파일형태로 저장
	- 모니터전환
		-  ⌥⇧N: (next)다음 모니터으로 포커스 이동
		-  ⌥⇧P: 왼쪽 (previous)이전 모니터으로 포커스 이동
	- 모니터에서 데스크탑 전환
		- **Control + 좌우 방향키** 
	- 지금 모니터의 데스크탑에서의 창전환
		-  ⌥⇧K (Move focus clockwise)
		-  ⌥⇧J (Move focus counter clockwise)
	
	- 문장내 빠른커서 이동
		- **문장 맨 앞으로 이동** : control +A
		- 줄(line)의 끝으로 이동 : Control + E
		- **단어 단위로 이동**: Option + 방향키
		
	- 삭제 단축키
		- 커서 이후 한 글자 삭제: Fn+ 지우기
		- 커서 앞의 단어단위 삭제: Option + 지우기
		- 커서 뒤의 한 단어 삭제 (일부 앱 한정): Fn + Option + 지우기
		- 커서부터 줄 앞까지 삭제: Command + 지우기
		
	- 커서는 그대로, 화면만 이동: Control + 방향키	
	- 완전위, 아래로이동: command + 방향키
-----
- ## 기본적인 의문: 스프링에서는 main말고 뭐가 필요할까?
	- ### **기본 main 외에 스프링에서 필요한 주요 기능들*
		스프링(Spring) 프로젝트에서 **main 하나만 있는 상태**라면, 지금은 기본적으로 “앱이 실행만 되는 상태”죠.
		
		실제 동작(예: API 처리, DB 저장, 비즈니스 로직 등)은 아래와 같은 **구성 요소(계층)** 들이 함께 만들어져야 작동합니다.
		- ### **@RestController** 클래스  
			- #### 사용자의 HTTP 요청(예: GET, POST)을 받아 처리하는 진입점
			- #### 우리가 요청 처리 메서드 직접 작성해야 함
			- URL 경로, 요청 방식, 파라미터 등을 @GetMapping("경로") 아래 매핑해서 서비스 호출함
			- 만약에 없다면? 브라우저나 Postman으로 요청을 보내도 **응답할 메서드가 없음**
		- ### **@Service** 클래스
			- #### 실제 비즈니스 로직(계산, 조건 분기 등)을 처리하는 핵심 로직 영역
			- #### 우리가 비즈니스 로직을 직접 구현,작성해야 함
			- 회원가입 시 비밀번호 암호화, 중복 확인 등
			- 만약에 없다면? 비즈니스 로직이 Controller나 Repository에 **뒤섞임 (계층 분리 안 됨)** 그래서 코드가 점점 스파게티처럼 엉켜 로직이 복잡해지면 유지보수가 매우 어렵고 테스트도 어렵고 재사용도 불편
		- ### **@Repository (DAO)** 인터페이스
			- #### **DB에 저장/조회/수정/삭제하는 기능 담당 (동작/로직)**
			- #### **인터페이스만 작성하면 JPA가 자동 구현체를 만들어줌** , 우리가 직접 구현하지 않음
			- DB에 대한 접근 로직을 담당 (JPA/Hibernate/SQL 등 사용)
			- 만약에 없다면? DB에 접근할 방법이 없음 (CRUD 불가)
				비즈니스 로직은 있어도 DB에 데이터를 저장하거나 읽어올 수 없음JPA의 자동 SQL 생성 기능을 쓸 수 없음
				직접 JDBC 코드를 짜야 함 (코드 많고 오류 가능성 ↑)
		- ###  **DTO(Model)** 클래스
			- #### 데이터를 담는 객체 (계층 간 전달 )
			- #### 우리가 작성하는 단순히 데이터를 담는 클래스
			- 우리가 정의한 데이터구조클래스로 계층 간 데이터를 안전하게 전달함
			- 예) UserDTO는 화면 입력 값 담기  
			- 만약에 없다면?  Controller와 Service/Entity 간의 **명확한 데이터 전달 경로가 없음**
				- 요청이나 응답 데이터를 엔티티로 직접 처리하게 되면 보안, 유효성 검증, 확장성 문제 발생
				- 예: UserEntity에 패스워드나 내부 필드까지 외부로 노출될 수 있음
		- ###  **@Entity** 클래스
			- #### DB 테이블과 1:1로 매핑되는 클래스 (DB 매핑용)
			- DB에 저장될 데이터가 **어떤 필드와 타입**으로 저장되는지를 정의
			- JPA에서 사용되며, 실제 DB에 저장되는 데이터 구조 정의
			- 예) User Entity는 DB 테이블과 매핑
			- DTO는 사용자 요청/응답에 사용되고, Entity는 DB 저장용으로 쓰인다
			- 만약에 없다면? DB와 연동할 수 있는 모델이 없음
				- JPA가 테이블과 연결할 클래스를 찾지 못해서 **데이터 저장/조회 불가**
				- 즉, 서버 안에서는 로직이 돌아도 DB에는 아무 데이터도 기록되지 않음
		- ### **application.properties** /  **application.yml**
			- #### 프로젝트 설정값을 정의하는 구성 파일
			- 포트, DB 주소, 시큐리티 설정 등 모든 전역 설정을 관리
			- 만약에 없다면? 서버가 어떤 포트를 사용할지, 어떤 DB에 연결할지 모름
				- DB 연결, 로깅, 보안 등 필수 설정이 빠져서 앱이 실행조차 안 될 수 있음
		- ### **@ControllerAdvice**  클래스
			- #### 서버에서 발생하는 예외(Exception)를 처리하는 공통 모듈
			- #### 스프링이 Bean으로 등록하여 전역 예외 처리 로직을 실행하기 위해, 우리가 직접 작성하는 클래스
			- @ControllerAdvice아래 클래스 안에 **@ExceptionHandler**으로  사용자가 보기 좋은 에러 메시지를 반환하거나 로깅할 수 있음
			- 만약에 없다면? 예외 발생 시 스프링이 예쁘게 처리하지 못하고 **기본 에러 메시지**를 그대로 반환함
				- 클라이언트는 무슨 에러인지 이해할 수 없고, 보안상 내부 코드 정보가 노출될 수 있음
		- ### **@SpringBootTest** 클래스
			- #### 기능 단위로 코드가 잘 작동하는지 검증하는 자동 테스트용 클래스
			- 실제 서비스를 돌리지 않아도 자동으로 확인 가능
			- 만약에 없다면? 애플리케이션이 정상적으로 작동하는지 **자동 검증할 수 없음**
				- 배포 전에 모든 걸 **수동으로 확인**해야 하며, 에러 발견이 늦음
	- ### DTO vs Entity
		- ##### **DTO는 서로 말 주고받을 때 쓰는 편지봉투, 겉에 이름, 주소만 써서 주고받기 편하게 만든 거야, Entity는 진짜 저장되는 진짜 물건이라 튼튼하고 정확해야해**
		- DTO **(Data Transfer Object)**
			-  **목적**: 클라이언트와 데이터를 주고받기 위한 전달용 객체
				-  “이 API는 어떤 데이터를 받아야 하고, 어떤 데이터를 돌려줘야 하지?”라는 기능에 맞춰 , **각 API별로 요청(RequestDTO), 응답(ResponseDTO)** 를 먼저 정의해.
				- 요청/응답 목적에 맞춰 **API 중심으로 설계**
			-  **필드 최소화, 민감 정보 절대 제외** (노출이 된다는 전제로 만들어짐)
				- **비밀번호는 DTO로 받아야 하지만, 그 자체로 저장하거나 노출하면 안 된다.**
				- 민감정보를 넘겨받아야할경우
					- 민감정보는 RequestDTO에서는 받아도 된다
					- 하지만비밀번호, 리프레시 토큰, 로그인실패횟수, 내부처리 상태값은 ResponseDTO로 절대 클라이언트에게 보내면 안 된다
					- **전송 중엔  **HTTPS로 암호화된 통신 채널**을 사용함으로써, 네트워크 중간에서 탈취되지 않도록 보호
				- DTO는 “전달 수단”일 뿐, **해싱 등의 보안 로직은 포함하지 않음**
			- entity에 넣기전 **서버에서 암호화(해싱)**
				- 비밀번호 그대로 entity에 넣으면 안됨
				- **혹시라도 DB가 털리더라도, 비밀번호를 바로 알 수 없게 하기 위해서** 해싱함
				- 서버말고 클라이언트에서 해싱 하면, 네트워크 중간에서 해시 값이 그대로 유출될 수 있음
			- API 요구에 따라 **자주 변할 수 있음**
			- 기능별로 DTO 여러 개 만들어서 **목적에 따라 다양하게**
			- DTO는 DB용이 아니기 때문에, Entity와 서로 변환이 필요해.
				- 이건 보통 **Service나 Mapper 클래스**에서 처리해.
				-  대부분 DTO → Entity으로 변환하는 단방향 (입력용 중심)
		- Entity **(DB 저장용 객체)**
			- 실제 DB 테이블과 매핑되어 데이터 저장/조회용으로 사용
			- DB 중심 설계 (정합성, 무결성 우선)
			- 내부 데이터이므로 **모든 필드(정보) 포함 가능** 
				- Entity에만 **비밀번호, 토큰, 생성일** 등 내부정보를 다 포함 
				- DTO에는 데이터를 전달만 하기 때문에 사용자 이름, 이메일 정도만 포함하고 내부정보 안넣음
			- 한 번 정하면 쉽게 못 바꿈 (바꾸면 DB 마이그레이션 위험)
			- 여러 서비스가 공유해서 **단일 구조로 유지**
			- Entity를 외부에 반환하지 않음
				- Controller에서 Entity를 반환하면 보안/유지보수 위험 있음.
				- 클라이언트에 직접 노출x
				- DTO만 컨트롤러에서 노출, Entity는 DB 전용으로 유지
			- JPA 제약, 관계, Index 등 정확히 설계해야 함.
---
- ### 용어 명확히 정의할 필요성이 있다
	- 서버: 요청을 처리하는 주체
		- serve(제공하다) +er(~하는 사람): 기능을 제공하는 것
		- 이때의 기능은 회원가입기능/ 정보가져오기 기능/ 추천기능등을 컴퓨터(서버) 가 제공
		- 서버
			- 기능을 제공하는 프로그램
			- 그 프로그램을 실행시키는 컴퓨터 
	- 요청
		- 기능을 제공하기 위해선 요청이 필요하다
		- 컴퓨터에게 어떻게 요청을 하지?
			- 인터넷을 거쳐서 요청
	- **URL 요청**
		- **요청(Request)** = “서버에게 어떤 동작을 해달라고 보내는 메시지”
		- **컨트롤러(Controller)** = “요청을 받아서 처리하는 코드”
		- **URL (Uniform Resource Locator)** = 서버 내에서 여러기능들중 어떤 컨트롤러(혹은 특정 기능)로 요청을 보낼지 결정하는 역할
	- API: **어떤 기능을 외부에서 사용할 수 있도록 제공하는 인터페이스**
		- 웹개발: 서버의 특정기능을 호출하는 인터페이스
		- 프로그래밍: 특정기능을 제공하는 모듈 즉 라이브러리 API를 의미
	- api요청이랑 HTTP요청
		- HTTP 요청: 데이터 전달 방식
			- **'인터넷'을 통해 데이터를 주고받는 방식**
			-  **웹사이트를 열거나, API를 호출할 때 모두 HTTP 요청을 사용**
		- API 요청: 기능호출
			- **API 기능을 호출하는 것** (이때 HTTP요청을 포함할수 있음)
			- **서버 내부에서 실행되는 API 요청**
				- **데이터베이스와 직접 통신하는 API 요청은 HTTP 요청을 사용하지 않음**
	- 클라이언트: **서버에게 요청보내는 존재**
		- api 클라이언트: api를 요청를 보내는 쪽(프로그램, 도구)
			- '웹에서' api를 호출하는 주체를 프론트엔드 클라이언트라고 한다
		-  단순히 프론트개발자의 프론트다 이렇게 이해하기엔 너무 큰 범위의 단어
			- **클라이언트(Client)** = **서비스(서버)에게 요청을 보내는 모든 주체**
			-  **API 클라이언트(API Client)** = **API를 요청하는 주체(프로그램, 도구 포함)**
			- **프론트엔드 클라이언트(Frontend Client)** = **웹에서 API를 호출하는 주체(React, Vue, HTML+JS 등)**
	- 도메인: 특정영역
		-  웹에서는 인터넷 주소를 관리하는 범위  
			- naver.com를 예로들면  “네이버가 관리하는 인터넷 주소 범위”라는 의미로 쓰임**
			- naver.com같은 인터넷 주소(URL)즉 IP주소를 사람이 이해하기 쉽게 만든것
		- 소프트웨어에서는는 **“애플리케이션이 다루는 핵심 데이터(비즈니스 영역)“라는 의미**
			- 웹 개발에서 “도메인 모델(Domain Model)“은 **핵심 데이터(예: User, Product, Order)를 표현하는 객체**
	- 비즈니스 로직vs 애플리케이션의 핵심데이터 모델(Domain Model)
		- 비즈니스 로직: 데이터를 처리하는 규칙, 계산, 검증 등의 로직
			- Order 클래스안의 calculateTotalPrice() 메서드는 **비즈니스 로직** (할인 규칙)
		- **애플리케이션의 핵심 데이터 모델(Domain Model)** = **“비즈니스 데이터를 담는 객체”**
			- Order 클래스는 **도메인 모델** (핵심 데이터)
		- **핵심 데이터 모델은 데이터를 저장하고, 비즈니스 로직은 데이터를 어떻게 다룰지 정의하는 것**
	- 모듈 vs인터페이스
		- 인터페이스는 설계도
		- 모듈은 인터페이스를 구현한 코드덩어리
	- 엔티티: 데이터의 실체
		- 소프트웨어에서는 비즈니스 데이터를 담는 객체
		- 데이터베이스에서는 테이블의 한 행(row)
	- 컨트롤러: **요청을 받아서 처리하는 역할**
		- 웹: 클라이언트 요청을 처리하는 부분
		- **프레임워크**: HTTP 요청을 받아서 서비스 로직 호출
	- **서비스** :  **비즈니스 로직** 을 담당하는 계층
		- 소프트웨어: 컨트롤러에서 받은 요청을 처리하는 계층
		- 운영환경: AWS
	- 세션, 쿠키, 캐시: 데이터를 저장한다 그러나 저장위치와 목적이 다름
		- 세션: **서버에서 로그인 상태 유지** ->서버메모리에 저장
		- 쿠키: **클라이언트(브라우저)에 데이터 저장**
		- 캐시: 빠른데이터접근을 위한 임시저장소(브라우저,cdn,서버)
	- **리포지토리**: 데이터 저장,관리하는 개념
		- **Git**: 버전관리를 위한 코드저장소(깃허브, 깃랩)
		- 백엔드개발: DB랑 상호작용하는 계층
			- Spring JPA UserRepository
	- 스펙(spec, specification): 기술 명세서
		- **API 설계에서 “API 스펙”은 API의 요청/응답 형식을 정의하는 문서**
			- **“너 스펙 좋다”의 스펙과는 완전히 다른 개념**
			- **취업에서 “스펙”은 학력, 경력, 자격증을 의미**
	- 라우팅:  **요청을 적절한 곳으로 연결하는 것**
		- **백엔드 개발**의 라운팅 :특정 URL 요청을 컨트롤러로 연결 (@GetMapping("/user"))
		- **네트워크 라우팅**: 패킷을 적절한 네트워크 경로로 전달
	- 배포, 빌드: 소프트웨어를 실행할 준비를 하는 과정
		- 빌드: 코드를 실행 가능한 상태로 변환하는 과정
			- 즉 실행 가능한 파일을 생성
		- 배포: 빌드된 애플리케이션을 서버에 업로드해 실행하는 과정
	- 서버부하관리
		- **로드 밸런싱: 하나의 요청을 여러 서버에 트래픽을 균등하게 분산하는 것**
		- 스케일링: 서버 자체의의 개수를 늘리거나 줄이는 과정
	- 쿼리: 질문, 어떤 시스템에 정보를 **요청하는 형태**
		- SQL 쿼리: DB에 조건을 붙여 데이터를 요청하는 문장
		- HHTP 쿼리: 서버에 조건을 붙여 리소스를 요청하는 부분

URL의 ? 이후에 붙는 key=value 형태의 데이터
---
- ### 전체적인 호출 흐름
	1️⃣ 유저가 버튼 클릭 → 브라우저가 **API 클라이언트**를 실행하여 API 요청 생성 (`GET /users/1`)
	2️⃣ HTTP 요청이 서버(Spring Boot)로 전송됨
	3️⃣ 서버가 HTTP 요청을 해석후 **URL에서 {id} 값을 추출** (id = 1)해 해당 컨트롤러로 요청 전달 (`UserController`)
	4️⃣ **컨트롤러는 요청을 받으면 실제 데이터를 가져오기 위해 서비스(Service)를 호출** → DB에서 유저 데이터 조회
	5️⃣ 서버가 JSON 응답을 생성하여 클라이언트로 반환 (`200 OK`)
	- 서버는 ResponseEntity.ok(user)를 사용하여 HTTP 응답을 생성하고 반환
	6️⃣ 브라우저가 응답을 받아 화면에 유저 정보 표시
---
- ## <본격적 강의내용>
- ### 1_3 네트워크란 무엇인가?
	-  A동에서 B동으로 택배로 물건을 보낼때마다 주소가 너무 길어 외우기 어려우니 파랑집 둘째라고 축약
		- IP 주소가 **컴퓨터를 찾는 고유한 주소**라면, **포트**는 **컴퓨터 내부에서 실행 중인 특정 프로그램(서비스)을 구분하는 번호**
		- ip주소와 포트을 주소로 데이터를 전달
		- 도메인이름: 244.~~~ 숫자대신 사람들이 외우기 쉬운 이름을 넣자! -> naver.com
---
- ### 1_4 HTTP와 API란 무엇인가
	- #### HTTP란 **메시지를 보내는 형식**(프로토콜)
		- 택배운송장은 기입하는 순서의 표준이 약속되어있다.
		- 인터넷에서 데이터를 주고받을때의 표준이, 약속이 있다 그 약속을 HTTP라 부른다.
		- HTTP (하이퍼텍스트 트랜스퍼 프로토콜)
		```c++
			1. 요청라인 혹은 상태라인
			2. Header(헤더) //추가적인 요청 혹은 응답정보 제공 
			//헤더와 바디를 구분하는 공백줄
			3. Body(본문,선택적) //받을 컴퓨터에 줄 실제정보
		```
		1.  HTTP  **요청** 
			## Request
			Request하는 컴퓨터 => 클라이언트
			```c++
			/*<1.요청라인>*/  (HTTPMethod) /(요청URL) HTTP/(프로토콜버전)
			```
			- 필수: 첫번째 줄(요청라인) 
				- HTTPMethod: 야 넌 이 동작해줘
					- GET(이 데이터 줘, 쿼리):  서버 데이터를 가져옴(읽기전용)
					- POST(이 새 데이터 생성해, 바디): 데이터를 서버에 전송
					- PUT(이 데이터 대치해, 바디): 서버 데이터를 전체 수정(덮어쓰기)
					- PATCH(이 데이터 일부 수정해, 바디): 서버 데이터를 부분수정
					- DELETE(이 데이터 삭제해, 쿼리): 서버의 데이터를 삭제
				- 요청 URL: 누구에게 요청을 보내야 하는지
					- 컨트롤러클래스식별자/메소드식별자?쿼리=값
					```Java
					@RestController
						@RequestMapping("/컨트롤러클래스식별자") // 공통 prefix 만약에 user/1이 있고 book/1이 있을때 user,book 구분용 모든 메서드가 user이면 requsetmapping에 user써주고 ~mapping 경로 비워주면됨
						public class UserController {
						
						    @GetMapping("/메소드식별자") // 특정 사용자 조회
						    public User getUser(@PathVariable Long id) {
						        return userService.findById(id);
						    }
						
						    @PostMapping("") // 사용자 등록
						    public void createUser(@RequestBody UserDTO dto) {
						        userService.save(dto);
						    }
						}
					```
					- 이때 쿼리=값부분은 생략가능
				- HTTP/프로토콜 버전: 이 방식으로 소통할께 (HTTP의 버전)
				- 참고)URL  vs 요청URL 
					- 그냥 URL양식 : 웹상에서 프로토콜, 도메인 등 포함한 전체 경로
						- https://example.com/api/users?name=kim
						- \[프로토콜]://\[도메인]:\[포트]/\[경로]?쿼리=값
							- ://은 구분기호
						- 이떄 포트번호와 쿼리=값은 생략가능
					- 요청 URL :**URL 중 경로?쿼리=값 부분만**
						- /api/users?name=kim
						- 이때 쿼리=값부분은 생략가능
			```c++
			/*<2.Header>*/  HOST: 요청할 서버의 도메인 주소 
			/*<3.공백줄>*/ 
			```
			- Host부분만 필수 : 두번쨰 줄(헤더)
				- Host: IP주소:포트번호 혹은 도메인
				- Content-Type : 요청 본문의 타입
					- application/json
				- Authorization: 인증 정보
					- Bearer abc123
			```c++
			/*<4.Body>*/    (서버에 보낼 데이터정보)
			```
			- 생략가능: 3번째 줄 이상
				- 서버에 보낼 데이터 정보: 사용자의 로그인 정보를보내 로그인 요청
			- 요청에서 데이터를 전달하는 2가지 방식
				- body:HTTP 요청 body에 작성
					- **“데이터를 저장하거나 변경할 때”** POST, PUT, PATCH에서 사용
					- @RequestBody를 사용하면 JSON 데이터를 객체로 변환 가능
				- 쿼리: HTTP 요청URL에 작성
					- **쿼리 파라미터를 사용하면 URL만으로도 요청을 이해할 수 있음**
					- **서버에게 어떤 데이터를 조회할지 조건을 전달**
					- @RequestParam을 사용하면 URL에서 전달된 name, age 값을 받을 수 있음
					- URL에 노출되어 보안문제
				- **URL에 포함할 수 있는 데이터(짧고 간단한 데이터)는 쿼리에 넣고, 긴 데이터(파일, JSON)는 바디에 넣음**
		2.  HTTP  **응답**
			## Response
			Response하는 컴퓨터 => 서버
			```c++
			/*<1. 요청라인>*/HTTP/(프로토콜버전) (상태코드) (상태메세지)
			/*<2. Header>*/
						   Date: (응답 생성 시간)
						   Server: (서버종류)/(서버버전) 
						   Content-Type: (응답데이터의 타입)
						   Content-Length: (응답데이터 길이)
			/*<공백줄>*/ 
			/*<Body(본문)>*/(응답데이터)
			```
			- 프로토콜 버전 : “이 방식으로 소통했어!”
			- **Status Code**(상태코드) : “요청 결과가 어땠는지” 서버의 응답 상태를 나타내는 숫자 코드
			- **Status Message**(상태메세지): 상태코드를 사람이 이해하기 쉽게 표현한 메세지
			- 저 4개이외에 자주 사용되는 Response헤더
				```c++
				Set-Cookie: (쿠키설정) //클라이언트에세 쿠키 저장 요청
				Location: (리디렉션 수행할 주소) //location이 사용된다면 요청코드에 상태코드가 추가로 적힌다.
				Cache-Control: (캐시설정)//캐시정책설정(데이터 유지여부)
				```
				- 쿠키설정에 들어가는 속성
					- Path=/(쿠키를 사용할 경로설정);
					- Domain=(쿠키를 사용할 도메인지정);
					- HttpOnly;
						- 자바스크립트에서 접근불가능(보안강화)
					- Secure;
						- HTTPS에서만 전송가능
					- Expires=(쿠키만료일);
					- Max-Age=(쿠키가유효한 초단위)
					- SameSite=Strict;
						(CSRF 방지)
				- 리디렉션 주소
					- 서버가 클라이언트에게 **다른 URL로 이동하라고 지시하는 헤더**
					- 리디렉션(페이지 이동)
				- location사용될때 요청코드에 추가되는 상태코드
					- 영구적/일시적이동등을 지시한다.
				- 캐시 정책 설정
					- 클라이언트가 **어떤 데이터를 캐시할지, 얼마나 오래 유지할지**를 결정
				- 캐시 vs 쿠키
					- 캐시:  임시로 **웹사이트의 데이터**를 저장해서 웹사이트 속도를 빠르게** (똑같은 데이터 다시 다운x하고 불러오기)
					- 쿠키:  사용자 정보 저장 (보안위험있음)
			- body에  사용되는 데이터 유형
				- HTML :웹페이지 콘텐츠
				- JSON : API 응답데이터
				- XML : 구조화된 데이터
				- 파일데이터 ex) img,pdf 등
	- #### API는 **인터페이스**(프로그램들끼리의 대화수단)
		- **API** = **A**pplication **P**rogramming **I**nterface
		- 한 프로그램이 다른 프로그램의 기능을 사용하거나 데이터를 주고받을수 있도록 연결해주는 중간 역할을 하는 규칙
			- 정해진 약속을 하여 특정기능을 수행하는 것
			- 웹툰서버와 유저가 웹툰을 주고받기 위한 메뉴판
			- 유저가 웹툰을 가져오라는 코드를 어떻게 작동시켜~
			- 그래서 이 url로 get요청하면 웹툰 가져올수있게 하자 라는 코드를 작성 이때의 코드를 api라 한다.
			- 유저가 get요청하는 코드를 못짜는데요?
				- 브라우저의 주소창이 유저가 api요청 코드 짜는 곳이라고 보면된다(Get 요청하는)
				- 그리고 Html 이미지 누르면 get요청하게 해놓으면 되고~
		- **두 프로그램이 데이터를 교환할 때 “어떤 방식으로 대화할지 정의”** 한 약속
		- 우리가 직접 코드를 짜지 않고도 특정 기능을 쉽게 사용할 수 있도록 제공되는 도구
		- API 종류
			- Web API(인터넷을 통한 소통 인터페이스 API)
				- REST API, GraphQL
			- OS API(운영체제가 제공하는 인터페이스 API)
			- Library API(특정기능를 쉽게 사용하게 해주는 API)
			- Hardware API(하드웨어와 소프트웨어가 소통하는 API)
	- REST API : 프로그램끼리의 대화수단인데, 데이터를 전송할때 HTTP형식으로 전송하는~


- 이해안가서 일단 정리한 순서
	- 저 위의 HTTP요청(클라이언트->서버)/ HTTP 응답(서버->클라이언트)의 양식은 유저나, 개발자가 직접작성하는게 아님
		- 유저가 직접 작성하지 않아도 API 클라이언트(**웹 브라우저, Postman, 프론트엔드 코드(fetch, axios))가 HTTP 요청을 자동 생성함.** 
			- **API 클라이언트는 API 요청을 보낼 수 있도록 해주는 프로그램 또는 도구를 의미**
		- **Spring 같은 백엔드 프레임워크가 요청을 자동으로 해석하고 처리해 줌**
	- **API가 동작하는 전체 과정은 “클라이언트 → 서버 → 데이터베이스 → 서버 → 클라이언트” 순서로 진행됨.**
---
- ### 1_5 GET API 개발하고 테스트
	- cmd+n :새로운 패키지/파일..등 만들기
	- ### option+⬆️: 범위지정 
		- 계속화살표위 누르면 범위가 커진다.
	- control+option+o : 안쓰는 import문 삭제
	- option+enter: import문 생성
- 두개의 숫자를 받아 덧셈결과를 반환하는 api를 만들어보자.
	- 일단 나는 REST API를 쓸거야(HTTP요청을 사용하는)
	- Postman으로 api요청을 보내고 응답을 받아보자
	- 그러면 요청을 받고, 응답을 보내는 코드만 작성하면 되겠네
	- 1. API Spec(ification) : 어떻게 api를 만들지?  
	    - HTTP Method -> GET   
		- HTTP Path -> /add   
		- 쿼리(key와 value) -> int number1/ int number2    
		- API의 반환결과 -> int
	- 2. 실제코딩
		- api를 개발할려는 클래스위에 @RestController를 적어주기
			- @RestController
				- 주어진 클래스를 컨트롤러로 등록한다
				- 컨트롤러: api의 진입지점
			- 그래서 클래스 안에 메서드를 만들어 api가 메서드 사용하도록 할수있다
		- 클래스 안에 @GetMapping()를 적고 ()안에 path를 적는다.
			- 이때의 Get이 HTTP 요청의 get이다
			- @GetMapping("/add")
				- 아래의 함수를 HTTP Method가 GET이고, HTTP path가 /add인 API로 지정한다.
		- 그리고 그 아래 기능을 구현한 함수를 만들어준다
			- 이때 함수가 쿼리를 통해 넘어온 데이터를 받아준다면, 매개변수 앞에 @RequestParam 이라고 적어준다.
			- @RequestParam
				- 주어지는 쿼리 파라미터값을 개별매걔변수에 넣어준다.
				- GET /add?number1=10&number2=20로 http를 통해 호출하면
				- 같은이름을 가진 쿼리의 값이 argument로 들어오게 된다.
	- 3. POSTMAN으로 만들어진 API테스트.
		- Postman키고 Get 누르고 주소창에 http://localhost:8080/.add
			- localhost :내컴퓨터라는 뜻
			- 8080: 서버동작하고있는 포트번호
		- 그리고 아래 params에 Key(변수이름) Value(변수 값)을 넣어준뒤 send를 클릭한다
			- Postman이 Url를 쉽게 작성해주고
			- send를 누르는순간 포스트맨이 http요청을 보내고 응답을 받는다.
	- @RequestParam를 매개변수에 넣어주면 많은값을 받을때 문제가 있다.
		- controller에서 @RequestParam를 제거하자!
		- 그리고 매개변수에는 객체를 받아준다.
		- how?
			- 새로운 클래스를 만들고 그 객체를 매걔변수로 받아준다. 
			- **Spring에서는 컨트롤러의 메서드 매개변수가
				- **기본 타입 (int, String 등)** 인경우→ @RequestParam 자동 적용
				- “객체(DTO)“인경우 기본적으로 매걔변수 앞에 @ModelAttribute를 적용한다
				- 이때 	DTO가 불변객체이면  **기본 생성자 & Setter가있어야** @ModelAttribute를 사용할수있다.
		- **DTO(Data Transfer Object, 데이터 전송 객체)**
			➡ **DTO 자체는 데이터를 전달하는 용도일 뿐, “쿼리 파라미터를 받는 클래스”가 되는 것은 아님!**
			✔ **DTO는 단순히 데이터를 담는 역할**
			✔ **어떻게 데이터를 받을지는 컨트롤러에서 어노테이션으로 결정됨**
---

- ### 1_6 POST API 개발하고 테스트하기
	- **POST 요청은 서버 데이터를 변경할 때 주로 사용되지만, 단순한 연산 API도 POST로 구현할 수 있다.**
	- **GET API에서는** 요청라인의 **쿼리 파라미터(Query Parameter) 또는 URL Path Variable**을 이용해 서버에 데이터를 전달한다.
		- 서버(API)는 URL에서 값을 읽어서 처리
	- **POST API**에서는 **HTTP Body** 이용해 데이터를(JSON형태로) 보낸다.
		- **Body에 데이터를 담아서 보내면**, API는 Body의 내용을 읽어서 정보를 가져온다.
			- Body 안에 **JSON 데이터**를 포함하여 전송
			- API는 **Body의 데이터를 읽어서 처리**
		- **Body에 데이터를 담을 때 주로 사용하는 문법이 JSON이다.**
		- 하지만 **JSON 외에도 XML, Form-Data 등 다양한 형식이 사용될 수 있다.**
		- JSON(JavaScript Object Notation)
			{ "key" : "value" }
			- 예시
				{
				"name": "최태현",
				"age": 99,
				"dogs": \["코코", "초코"],
				"house": {
					"address": "대한민국 서울",
					"hasDoor": true
					}
				}
				- Json의 속성 각각은 쉼표로 구분한다.
				- Json의 value에는 List가 올 수도 있다.
				- Json의 value에는 다른 JSON이 올수도 있다
	- 일단 나는 REST API를 쓸거야(HTTP요청을 사용하는)
	- Postman으로 api요청을 보내고 응답을 받아보자
	- 그러면 요청을 받고, 응답을 보내는 코드만 작성하면 되겠네
	- 1. 곱셈기능을 POSTAPI로 만들어보자(GET으로 만들수도 있긴하지만~)
		- HTTP Method -> POST
		- HTTP Path -> /multiply
		- HTTP Body(JSON) -> {
							"number1":숫자,
							"number2":숫자
							}
		- API의 반환결과 -> int(곱셈결과)
	- 2. 코드 작성
		- 한 Controller Class에 여러 API를 추가할수있다
			- @RestController를 적힌 클래스 안에 @PostMapping()를 적고 ()안에 path를 적는다.
			- 이때의 Post이 HTTP 요청의 Post이다
			- @PostMapping("/multiply")
				- 아래의 함수를 HTTP Method가 Post이고, HTTP path가 /multiply인 API로 지정한다.
		- 그리고 그 아래 기능을 구현한 함수를 만들어준다
			- **클라이언트가 JSON 데이터를 HTTP Body에 담아 요청하면,**, 매개변수 앞에 @Requestbody 이라고 적어준다.
			- @Requestbody
				- **HTTP Body(JSON)를 DTO 객체로 변환하는 역할을 한다.**
	- **@RequestBody** ? @RequestParam?
		✔ **@RequestBody는 JSON 데이터를 DTO 객체로 변환해야 하기 때문에 자동 변환이 필요**
		
		✔ **@RequestParam은 URL에서 개별 값으로 전달되므로, DTO 변환 없이 기본 타입으로 바로 받을 수 있음**
			✔ **URL에 포함된 데이터를 바로 개별 변수로 받을 수 있으므로, DTO 객체로 변환할 필요가 없음**
			✔ **쿼리 파라미터는 항상 문자열(String)로 전달되므로, Spring이 기본 타입(int, double 등)으로 자동 변환 가능**
		
		✔ **둘 다 “데이터를 받는 역할”이지만, 데이터의 위치(Body vs Query Parameter)와 처리 방식이 다름**
		
		👉 **즉, @RequestBody는 JSON을 DTO로 변환해야 하고, @RequestParam은 URL의 값을 바로 사용할 수 있기 때문에 객체 변환이 필요 없다!**
- **📌 @RequestBody, @RequestParam, @ModelAttribute 차이점 & 생략 가능 여부 정리**
	**✅ 1. @RequestBody 언제 사용?**
	
	**📌 JSON 데이터를 DTO 객체로 변환할 때**
	✔ **생략 불가능 → @RequestBody를 명시해야 JSON 데이터가 DTO 객체로 변환됨**
	
	---
	
	**✅2. @RequestParam 언제 사용?**
	**📌 URL의 Query Parameter에서 개별 값을 받을 때**
	✔ **GET 요청에서 개별 쿼리 파라미터 값을 받을 때 사용**
	✔ **String, int 같은 기본 타입 데이터를 받을 때 자동적용(생략 가능)**
	
	---
	
	**✅ 3. @ModelAttribute 언제 사용?**
	**📌 Query Parameter 또는 Form 데이터를 객체(DTO)로 변환할 때**
		✔ **GET 요청에서 여러 개의 쿼리 파라미터를 한 번에 객체로 받고 싶을 때 사용**
		✔ **Spring이 자동으로 Query Parameter 값을 DTO 필드에 매핑**
		✔ **DTO 클래스에 기본 생성자와 Setter가 필요**
		✔ **DTO 객체로 받을 경우 생략 가능 (@ModelAttribute 자동 적용됨)**
-  **✅ @RequestBody, @RequestParam, @ModelAttribute 비교표**

| **어노테이션**           | **데이터 위치**                    | **변환 결과**                 | **변환 방식**                                            | **주요 용도**                       | **생략 가능 여부**           |
| ------------------- | ----------------------------- | ------------------------- | ---------------------------------------------------- | ------------------------------- | ---------------------- |
| **@RequestBody**    | **HTTP Body (JSON, XML 등)**   | **DTO 객체**                | **Spring의 HttpMessageConverter를 통해 변환 (Jackson 사용)** | **POST, PUT에서 JSON 데이터를 받을 때**  | ❌ 생략 불가능               |
| **@RequestParam**   | **URL의 Query Parameter**      | **기본 타입 (int, String 등)** | **Spring이 자동 변환**                                    | **GET 요청에서 개별 값(쿼리 파라미터) 받을 때** | ✅ 생략 가능 (기본 타입만)       |
| **@ModelAttribute** | **Query Parameter, Form 데이터** | **DTO 객체**                | **Spring이 자동으로 객체 매핑**                               | **GET 요청에서 DTO 객체로 받을 때**       | ✅ 생략 가능 (DTO 타입 매개변수만) |

---

- ### 1_7  유저 생성 API 개발
	- 일단 나는 REST API를 쓸거야(HTTP요청을 사용하는)
	- Postman으로 api요청을 보내고 응답을 받아보자
	- 그러면 유저생성 요청을 받는코드, 했다고 응답을 보내는 코드만 작성하면 되겠네
	- 원래 api는 서버개발자가 내키는대로 만드는게 아님
	- 클라이언트 개발자(프론트)랑 서버 개발자(백엔드)랑 모여서 api를 같이 의논하고 설계하고 확정함
		- ui가 이미 만들어져 있으면 거기에 맞춰서 api를 만드는거임
	-  **도메인 기반/ 기능별(모듈별) 패키지 구조**: **사용자 관련 API는 user 패키지, 책 관련 API는 book 패키지에 정리**
	-  **int는 기본 타입(Primitive Type)이고, Integer는 객체(Wrapper Class)이기 때문에 Integer는 Null를 저장할수있다.**
		- 그래서 입력이 선택적인경우 wrapper class를 사용한다
- Request폴더를 생성해서하는 이유 Response와 구분하기 위해서
```
/src/main/java/com/example/libraryapp/dto
│── /calculator
│── /user
│   ├── /request  <-- (요청 DTO를 관리하는 폴더)
│   │   ├── UserCreateRequest.java  <-- 사용자 생성 요청 DTO
│   ├── /response  <-- (응답 DTO를 관리하는 폴더)
│   │   ├── UserResponse.java  <-- 사용자 정보 응답 DTO
```
```Java
@RestController
public class UserController {
    @PostMapping("/user")
    public void saveUser(@RequestBody UserCreateRequest request) {
        // 데이터 저장 로직 없음 -> DB에 저장되지 않음!
        /*
        ✔ **컨트롤러는 UserCreateRequest 객체를 받아들이지만, 실제 데이터 저장 기능이 없음**

✔ **이 상태에서는 클라이언트에서 요청을 보내도 데이터베이스(DB)에 저장되지 않음**
        */
    }
}
```
- 📌서버에 **데이터를 저장하려면 아래 3가지가 필요함**
	1. **Entity (User 엔티티, 도메인 모델)** → DB 테이블과 매핑될 객체(데이터 저장할 그릇)
	2. **Repository (UserRepository)** → 데이터베이스와 연결
		- ✅ **Repository 계층은 데이터베이스(DB)와 직접 연결되는 역할**
		- ✅ **UserRepository 없이 Controller에서 DB를 직접 다루면 유지보수성이 떨어짐**
	3. **Service (UserService)** → 비즈니스 로직 처리(복잡한 연산, 트랜잭션 관리, 여러 개의 Repository 조합)
	- domain : 애플리케이션에서 다루는 **핵심 비즈니스 개념**
		- 예를 들어, **“사용자(User), 책(Book), 주문(Order)”** 같은 핵심 데이터를 의미
- **컨트롤러는 “API 요청을 처리하는 기능”만 수행해야 하고, 데이터 저장(비즈니스 로직)은 Service에서 수행해야 합니다.**	
	✔ 클라이언트(프론트엔드)에서 보낸 요청을 받고, 적절한 서비스를 호출한 후 응답을 반환해야 함.
	✔ 하지만 **컨트롤러가 직접 DB를 다루면, API 요청 처리 + 데이터 저장까지 담당해야 하므로 역할이 애매해짐.**
	-> **컨트롤러는 Service를 호출하여 데이터 저장**하도록 하면됨
- 비즈니스 로직: 서비스의 핵심동작을 처리하는 로직
	- 단순히 데이터를 저장하는것이 아니라 어떤기준으로 데이터를 저장/조회/처리 할것인가를 결정하는로직
	- 즉 서비스의 핵심 기능을 정의하는것
	- 사용자가 입력한 결제 정보 저장하기에 비즈니스 로직을 추가하면
		- 카드 유효성 체크, 포인트 적용 후 저장하는게 추가된다

----

- ### 1_8  유저 조회 API 개발
	- 일단 나는 REST API를 쓸거야(HTTP요청을 사용하는)
	- Postman으로 api요청을 보내고 응답을 받아보자
	- 그러면 유저조회 요청을 받는코드, 응답을 보내는 코드만 작성하면 되겠네
	- API 스펙(spec, 설계문서)
		- "API 문서” 또는 “API 명세서”라고도 부름
		- API가 어떻게 동작하는지를 정의한 **설계 문서**
		- • 클라이언트(프론트엔드)와 서버(백엔드)가 원활하게 통신할 수 있도록 **API의 구조, 입력값, 출력값, 요청 방식 등을 명확히 정의**
	- 유저 조회 API 스펙
		- HTTP Method ->GET
		- HTTP Path -> :/user
		- 쿼리 -> 없음(전체유저데이터를 줄것이기 때문)
		- 결과반환 ->
			\[{
				"id" : Long // id는 식별용 번호 추가하자!
				"name" : String
				"price" : int			
			
			}...\]
	- 컨트롤러에서 객체, Getter가 반드시 있는 객체를 반환할때 JSON로 변환한다
		1️⃣ 컨트롤러가 `User` 객체를 반환
		2️⃣ `@RestController`가 반환된 객체를 HTTP 응답에 포함
		3️⃣ `Jackson` 라이브러리가 객체를 JSON 형식으로 변환
		-  **Jackson 라이브러리는 객체에 “Getter 메서드”를 이용**해서 변환하기에 객체에 getter가 있어야 JSON변환이 된다
		- Getter가 없으면 **Jackson이 데이터를 읽을 수 없기 때문에 JSON 변환이 제대로 되지 않음**
		-  getter없이 **필드에 직접 접근해서 JSON 변환을 하고 싶다면 @JsonProperty 또는 @JsonAutoDetect를 사용할 수 있음**
		4️⃣ 최종적으로 JSON 데이터가 클라이언트에게 전달됨
		- Fruit 클래스에 getName, getPrice 2개의 getter가 각자 반환했을때
			하나의 json으로 응답body로 반환한다.
			- {
			- "name": "사과"
			- "price": 1000
			- }
---

---
- ## 2장_1 Database와 MySQL
	- #### 1. 디스크와 메모리의 차이를 이해하고 Database의 필요성을 이해한다.
		- 서버를 종료하고 다시 실행후 새로고침하면 기존에 저장한 유저 정보가 날아가 버린다 
		- 먼저 컴퓨터의 핵심 부품을 이해해야한다
			- CPU : 연산
			- RAM : 메모리
				- 임시 저장장치로, cpu가 연산을 하면 중간에 기억해야 하는 것들을 재빠르게 램에 기록해 저장한다.
			- DISK : 하드디스크/SSD
				- 장기 저장장치
		- 서버실행시켜 API동작하기까지의 과정
			- 개발하고 있는 서버코드는 DIsk에 잠들어 있다.
			- 서버를 실행시키면 DISK에 있는 코드 정보가 RAM으로 복사된다.
				- 정보들이 단기기억쪽으로 
			- API가 실행되면 '연산'이 수행되며 cpu와 RAM을 데이터가 왔다갔다하며 저장한다.
				- 즉 POST API를 통해 생긴 유저정보는 RAM에 저장된다.
			- 서버가 종료되면 RAM에 있는 모든 정보는 사라진다.
				- 그래서 다시 서버를 시작하면 유저정보도 사라진 상태이다.
			- 그래서 저장자체가 DISK에 장기기록한다는 의미이다
		- 서버에서는 어떻게 DISK에 저장할 수 있을까?
			- File클래스 등을 이용해 직접 Disk에 접근할수있지만, 일반적으로 서버 애플리케이션은 이럴때 Database를 사용한다.
		- DataBase
			- 데이터를 구조화시켜 저장하는 것
			- RDB(Realational Database)
				- 데이터를 표처럼 구조화시켜 저장하는 것
				- 우리는 RDB의 종류중 대표적인 MySqL를 이용한다
		- SQL(Structured Qurey Language)
			- 표처럼 구조화된 쿼리(데이터)조회하는데 사용하는 언어
		- 즉 MySQL를 가동시키고 SQL이용해 데이터를 조회하거나 조작해야한다
	- #### 2. MySQL Database를 SQL과 함께 조작할 수 있다.
		- 먼저 MySQL를 가동해야한다
			- 인텔리제이 유료 사용시
				- 오른쪽 위 Database클릭
				- 실행 Command+ enter
		- SQL의 DDL(데이터를 정의하는 언어)
			- 컴퓨터에서 엑셀 파일에 과일정보를 기록한다고 해보자
				- 1. 우선 컴퓨터에 엑셀파일을 담을 폴더를 하나 만든다
				- 2. 폴더에 들어간다
				- 3. 폴더안에 엑셀파일을 만든다
				- 4. 엑셀파일(표)에 Header를 입력한다.
					- 이름, 가격, 입고일자
				- 5. 헤더별로 서식을 지정한다
					- 이 컬럼은 숫자야, 날짜야 등
				- 6. 데이터를 기록
			- MySQL에 데이터를 기록하자
				- 1. 우선 MySQL에 테이블을 담을 데이터 베이스를 하나 만든다
					- 데이터베이스 생성: create database 데이터베이스이름;
				- 2. 데이터베이스에 들어간다(테이블을 만들기위해)
					- 데이터베이스의 목록을 본다: show databases;
					- 데이터베이스를 삭제: drop database 데이터베이스이름;
					- 특정 데이터베이스에 들어간다: use 데이터베이스이름
				- 3. 데이터베이스안에 테이블을 만든다
					- 테이블들 목록을 확인: show tables;
					- 테이블 삭제 : drop table 테이블이름
					- 테이블 만들기
						- create table 테이블이름(
							필드1이름 타입 부가조건,
							필드2이름 타입 부가조건,
							...
							primary key (필드이름)
							);
						- 이때 primary key는 id로 설정하는게 일반적이고 id의 부가조건에는 auto_increment를 설정한다.
							- auto_increment: 설정되면 데이터를 명시적으로 넣지 않더라도 1부터 1씩증가하여 자동기록한다
							- primary key : 유일한 키라는 뜻으로 
								- 이름,가격,입고일자가 같더라도 primarykey가 다르면 다르다고 생각하자
						- mysql type, 부가조건은 외울필요없지만 정리~
							- mysql 정수 <-> Java 정수
								- tinyint: 1바이트 정수 <-> Byte
								- int: 4바이트 정수 <-> int
								- bigint: 8바이트 정수 <->Long
									- id는 21억건을 넘을 수있으므로 가장큰 bigint를 사용한다.
							- mysql 실수
								- double: 8byte 정수
								- decimal(A, B)
									- 소숫점을 B개 가지고 있는 전체 A자리수 실수
									- decimal(4,2)=12.23
							- mysql 문자열 
								- char(A)
									- 글자가 A개로 고정된 문자열
								- varchar(A)
									- 최대 글자가 A개까지 들어갈수있는 문자열
							- mySQL 날짜, 시간
								- date
									- 날짜, yyyy-MM-dd(기본포맷)
								- time
									- 시간, HH:mm:ss
								- datetime
									- 날짜와 시간을 합친 타입
									- yyyy-MM-dd HH:mm:ss
					- 테이블 삭제
					- 코드정리 단축기
						- option+command+I
				- 4. 테이블에 테이블의 필드를 정의한다.
					- 이름, 가격, 입고일자
				- 5. 테이블 필드별로 테이블의 필드 타입을 지정한다
					- 이 필드는 숫자야, 문자야 등
				- 6. 데이터를 기록
		- **DML (Data Manipulation Language)**:  **백엔드에서 직접 코드로 작성하는 SQL 문법들**
		- →**DML은 백엔드가 다루는 SQL, 그걸 CRUD로 4가지를 나눠서 설명한다***
			- CRUD
				- Create : 생성(데이터를 넣는다)
					- create 범위에 들어가는 SQL문법
						- INSERT – 가장 일반적인 데이터 삽입
						- INSERT INTO ... SELECT – 다른 테이블에서 가져와 삽입
						- REPLACE INTO – 기존에 동일한 키가 있으면 삭제 후 삽입 (MySQL 전용)
						- MERGE – 조건에 따라 INSERT or UPDATE (Oracle, SQL Server 등)
				- Read : 읽기(데이터를 조회한다)
					- read 범위에 들어가는 SQL문법
					- SELECT – 기본 조회 문법 
					- SELECT ... JOIN – 여러 테이블을 묶어 조회 
					- SELECT ... WHERE, GROUP BY, ORDER BY 등 – 조건부 조회, 그룹핑, 정렬 등도 포함
					- EXISTS, IN, LIKE, BETWEEN – 조건절로 사용되어도 읽기 범주로 봄
				- Update: 업데이트(데이터를 수정한다)
					- update 범위에 들어가는 SQL문법
					- UPDATE – 기본적인 행 단위 수정
					- UPDATE ... JOIN – 여러 테이블 기준으로 수정 (MySQL 지원)
					- MERGE – 조건에 따라 INSERT or UPDATE (Oracle, SQL Server 등)
				- Delete: 제거(데이터를 삭제한다)
					- DELETE – 조건에 맞는 행 삭제 
					- TRUNCATE – 테이블 전체 삭제 (DDL 성격도 있음, 롤백 불가)
					- MERGE – 조건에 따라 DELETE (일부 DBMS)
				- MERGE는 CREATE + UPDATE + DELETE의 복합 기능을 가진 특수 문법 (일부 DBMS에서만 지원)
				- TRUNCATE는 DELETE처럼 보이지만 DDL에 속함 (빠른 전체 삭제, 롤백 불가)
			- CRUD API작업하자
				- 어떤 대상에 대해 생성, 조회, 업데이트, 제거를 하는 api를 만든다.
			- 데이터 넣기
				- INSERT INTO 테이블이름 (필드이름1,필드이름2, ...)
					VALUES (값1, 값2, ...)
				- INSERT INTO, VALUES는 대문자가 아니어도 된다
				- 생성할때 id에 auto_increment설정을 해줬기 때문에 id는 따로 값을 넣어줄 필요가 없다.
			- 데이터 조회
				- select \* from 테이블이름
					- select 필드이름 from 테이블이름
					- select 필드이름1,필드이름2 from 테이블이름
				- select \* from 테이블이름 where 조건
					- 데이터를 조회할때 필터를 걸수있다.
					- 조건은 AND나 OR로 이어쓸수있다.
					- 조건
						- =, !=,<=, >=,<,>
						- between 첫번째범위 and 두번째범위
							- 첫번째 범위부터 두번째 범위까지(포함해서)
						- in ( value1, value2, ... )
							- 값이 이 목록안의 여러값 중 하나와 일치하니?
							- 걍 OR임
						- not in
							- 그 어떤 값과도 같지 않으면 TRUE
			- 데이터 수정
				- UPDATE 테이블이름
					SET 필드이름1=값1, 필드이름2= 값2, ...
					WHERE 조건
				- where 없이 조건을 쓰지않으면 모든 데이터가 업데이트 된다.
				- 이때 조건에 and, or 등을 사용할수있다.
			- 데이터 삭제
				- DELETE FROM 테이블이름
					WHERE 조건
				- where 없이 조건을 쓰지않으면 모든 데이터가 삭제된다.
	- #### 3. 스프링 서버를 이용해 Database에 접근하고 데이터를 저장, 조회, 업데이트, 삭제할 수 있다.
		- 2번은 사람이 직접 접근했던 방법
		- ##### 1. 사람이 아니라 스프링 서버가 MySQL DB에 접근할 수 있도록 해주자
			- Java와 같이 위치한 resourses패키지 안에  application.yml 파일을 통해 스프링서버가 접근할수있도록 설정할수있다.
				- spring:
					- datasource:
						- url: "jdbc:mysql://localhost/데이터베이스이름"
						- username: "root"
						- pasword: ""
						- driver-class-name: com.mysql.cj.jdbc.Driver
				- datasource:  스프링부트가 어떠한 데이터베이스를 가르키게 할것인가
				- url: spring이 붙을 데이터베이스 주소
					- jdbc: java-database-connector
						자바가 데이터베이스에 연결해주는 프로그램이름
					- 우리는 데이터베이스 종류를 mysql를 사용하고, 
					- 접근하려는 mysql은 나의 컴퓨터 localhost에 있다  
					- 그 후 우리가 사용하기위해 생성했던 mysql안의 데이터베이스 이름 써주기
				- 계정정보를 통해 접근
				- driver-classname: 데이터베이스에 접근할때 사용할 프로그램
		- ##### 2. 이제 우리 데이터베이스에 user테이블을 만들어 저장할수있게 하자
			- 인텔리제이 sql창 띄어서 생성
		- ##### 3. 유저 컨트롤러에 들어가서 메모리에 저장하던걸 mysql로 저장하게 바꿔주기
			- ###### 3_1) 파일 검색 단축키: command+shift+o 로 유저컨트롤러에 들어가서
			- ###### 3_2) 기존에 메모리에 저장하기위한 코드 private final List\<User> users = new ArrayList<>();를 지우고 
			- ###### 3_3) JdbcTemplate 선언한다
				- private final JdbcTemplate jdbcTemplate; 를 추가한다
				- jdbctemplate: jdbc 사용할수있게 해주는 클래스
			- ###### 3_4) jdbcTemplate 받아서 설정해주는 생성자를 만들어준다.
				- 스프링에 new 안쓰는이유: 누가 언제 New를 쓰냐에 따라 스프링이 관리여부가 달라짐
					- new를 우리가 쓰면 개발자가 직접 메모리 공간 할당하고 그후 생성자 호출하는거임 그냥 메모리 어딘가에 있는객체가 되는거임
					- Spring은 **“자기 컨테이너 안에 등록된 객체(Bean)“만 알고, 관리할 수 있어요.**
						- 스프링이 메모리 전체에서 객체 스캔하면 되잖아? 
							- New로 만든 모든 객체 추적은 불가능 너무 많아
						- **내가 new로 만든 객체를 넘겨주면, Spring이 그걸 받아서 관리해줄 순 없나?**
							- new를 우리가 쓰더라도 @bean 등록하면 관리받을수있다
							- Spring이 객체를 관리한다는 건 단순히 “생성을 대신 해준다”는 의미가 아니라, **엄청 많은 자동화된 기능을 그 객체에 붙여줄 수 있다는 의미**
							- **Spring한테 등록되면**, 그냥 new만 하던 객체가  **자동 주입, 트랜잭션, 설정 관리, AOP, 테스트 등 
							- 모든 슈퍼파워를 갖게 돼요.**
					- new: 개발자가 직접 객체를 **생성하는 키워드**
					- 생성자: JVM이 객체 생성 과정 중 자동 호출되는 메서드
				- spring의 의존성 주입 DI
					- Spring은 애플리케이션을 시작할 때 **Bean이라는 객체들을 모아서 Container에 등록**합니다. 그리고 필요할 때 자동으로 **주입(inject)** 해줘요.
					1. 클래스에 @Component, @Service, @Controller 등을 붙이면
					2. Spring이 **이 클래스를 Bean으로 등록**
					3. 객체 생성 시, 필요한 의존성을 찾아서
					4. **Spring이 내부적으로 new + 생성자 호출을 자동으로 해줌**
					5. 이때 만들어진 객체만 **Spring이 관리할 수 있음**
			- ###### 3_5) SQL를 만들어 문자열변수로 만들고 jdbcTemplate로 조작한다
				- 유저생성API
					```Java
					#예시 유저 생성api
					String sql="INSERT INTO user(name, age) VALUES(?, ?)";  
					jdbcTemplate.update(sql,request.getName(),request.getAge());
					```
					- jdbcTemplate.update()의 update는 SQL의 업데이트 의미가 아니다, **update, delete, insert 쿼리마다 메서드 따로 만들면 복잡해지니까**, **Spring은 데이터를 변경한다는 목적 기준으로 추상화**해서 update()라는 통합된 이름을 사용한 것.
				- 조회 API
					```Java
					#예시 메모리가 아닌, 데이터베이스에서 유저 목록을 가져오는 코드
					@GetMapping("/user")
					public List<UserResponse> getUsers() {
						String sql = "SELECT * FROM user";
										
					return jdbcTemplate.query(sql, new RowMapper<UserResponse>() {
						@Override
						public UserResponse mapRow(ResultSet rs, int rowNum) throws SQLException {
							return new UserResponse(
								rs.getLong("id"),//그 한줄에서long타입 변수를 가져오고 그 이름은 Id다
								rs.getString("name"),//
								rs.getInt("age")
							);
						}
					});
					}
						```
					- jdbcTemplate.qurely(sql, new **new RowMapper\<UserResponse>() {...}** );
					- JdbcTemplate.query()는 query()는 SQL을 DB에 전달해서,“이 조건에 맞는 데이터를 주세요!"라는 **질문(Query)** 을 날리는 메서드
						- query() 메서드를 사용해 sql 문장을 DB에 날린다
						- DB가 결과를 ResultSet 형태로 돌려준다
						- 두 번째 인자는 결과를 **어떤 객체로 변환할지**를 지정하는 RowMapper로 설정한다
						- query()메서드는 그걸 **List로 자동으로 모아서 반환**해줘요.
					- RowMapper는 DB 테이블의 한 줄(Row) 을 Java 객체로 바꾸는 도구이고, maprow()를 오버라이딩하기위한 인터페이스
						- ResultSet: DB 결과 전체를 담는 자바 객체
						- 이때 ctrl+o를 눌러 maprow() 오버라이딩을 해줘야해
						- maprow()
							- ResultSet의 한줄을 Java 객체(T)로 변환하는 메서드(변환로직은 우리가 작성해야함)
					- <총정리>
					- 1.JdbcTemplate.query()가 SQL을 DB에 전달하고	
					- 2.DB에서 결과를 ResultSet 형태로 받아옴
					- 3. query()가 ResultSet을 한행씩 순회하면서 각행을RowMapper의 mapRow() 메서드로 넘겨주는 구조
					- 3. mapRow() 메서드는 그 한줄을 UserResponse 객체로 바꾸고
					- 4.query()가 변환된 객체들을 리스트에 모아주고 모든 객체가 변환되면 그 리스트를 반환한다
					- 그래서JdbcTemplate.query()가 반환한걸 클라이언트에 주면 된다.
				- 업데이트 API
					```Java
					#예시 업데이트 API
					@GetMapping("/user")
					public List<UserResponse> getUsers() {
						String sql = "SELECT * FROM user";
										
						return jdbcTemplate.query(sql, new RowMapper<UserResponse>() {
							@Override
							public UserResponse mapRow(ResultSet rs, int rowNum) throws SQLException {
								return new UserResponse(
									rs.getLong("id"),//그 한줄에서long타입 변수를 가져오고 그 이름은 Id다
									rs.getString("name"),//
									rs.getInt("age")
								);
							}
						});
					}
					```
				- 삭제 API
					```Java
					#예시 삭제API
					@GetMapping("/user")
					public List<UserResponse> getUsers() {
						String sql = "SELECT * FROM user";
										
						return jdbcTemplate.query(sql, new RowMapper<UserResponse>() {
							@Override
							public UserResponse mapRow(ResultSet rs, int rowNum) throws SQLException {
								return new UserResponse(
									rs.getLong("id"),//그 한줄에서long타입 변수를 가져오고 그 이름은 Id다
									rs.getString("name"),//
									rs.getInt("age")
								);
							}
						});
					}
					```
	- #### 4. API의 예외 상황을 알아보고 예외를 처리할 수 있다.

| **JdbcTemplate 주요 메서드명** | **용도**                    | **리턴타입**      | **특징/비고**              |
| ------------------------ | ------------------------- | ------------- | ---------------------- |
| update()                 | INSERT, UPDATE, DELETE    | int (변경된 행 수) | 데이터를 변경할 때 사용          |
| query()                  | SELECT (여러 행)             | List<T>       | 여러 행을 RowMapper로 매핑함   |
| queryForObject()         | SELECT (결과가 1개 행 & 1개 컬럼) | T             | 단일 값(ex. count) 조회에 사용 |
| queryForList()           | SELECT (결과가 여러 행, 1컬럼)    | List<T>       | 단일 컬럼만 여러 행으로 받을 때     |
- 여기까지 듣고 스스로 실습한 정리
	- 값이 null이 들어올수 있는거는 int가 아닌 객체 Integer를 사용한다
	- 생성자를 만들어줄 필요가 없는경우
		- spring이 json->객체로 변환할땐 기본생성자+getter만있으면 된다
	- 생성자는 어떨때 만들어주는가?
		- 불변객체(DTO)를 만들어 주고 싶을때, final필드+ 생성자를 추가로 만들어줘야한다.