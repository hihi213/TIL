- 서버
	- serve(제공하다) +er(~하는 사람): 기능을 제공하는 것
	- 이때의 기능은 회원가입기능/ 정보가져오기 기능/ 추천기능등을 컴퓨터(서버) 가 제공
	- 서버
		- 기능을 제공하는 프로그램
		- 그 프로그램을 실행시키는 컴퓨터 
- 요청
	- 기능을 제공하기 위해선 요청이 필요하다
	- 컴퓨터에게 어떻게 요청을 하지?
		- 인터넷을 거쳐서 요청



- ### 1_3 네트워크란 무엇인가?
	-  A동에서 B동으로 택배로 물건을 보낼때마다 주소가 너무 길어 외우기 어려우니 파랑집 둘째라고 축약
		- IP 주소가 **컴퓨터를 찾는 고유한 주소**라면, **포트**는 **컴퓨터 내부에서 실행 중인 특정 프로그램(서비스)을 구분하는 번호**
		- ip주소와 포트을 주소로 데이터를 전달
		- 도메인이름: 244.~~~ 숫자대신 사람들이 외우기 쉬운 이름을 넣자! -> naver.com
	- 도메인(영역)이 뜻하는게 다르다고?
		-  naver.com를 예로들면 **웹 주소에서도 “네이버가 관리하는 인터넷 주소 범위”라는 의미로 쓰임**
			- naver.com같은 인터넷 주소(URL)즉 IP주소를 사람이 이해하기 쉽게 만든것
		- 소프트웨어에서는 **“애플리케이션이 다루는 핵심 데이터(비즈니스 영역)“라는 의미**
			- 웹 개발에서 “도메인 모델(Domain Model)“은 **핵심 데이터(예: User, Product, Order)를 표현하는 객체**

- ### 1_4 HTTP와 API란 무엇인가
	- #### HTTP란 **메시지를 보내는 형식**(프로토콜)
		- 택배운송장은 기입하는 순서의 표준이 약속되어있다.
		- 인터넷에서 데이터를 주고받을때의 표준이, 약속이 있다 그 약속을 HTTP라 부른다.
		- HTTP (하이퍼텍스트 트랜스퍼 프로토콜)
		```c++
			1. 요청라인 혹은 상태라인
			2. Header(헤더) //추가적인 요청 혹은 응답정보 제공 
			//헤더와 바디를 구분하는 공백줄
			3. Body(본문,선택적) //받을 컴퓨터에 줄 실제정보
		```
		1.  HTTP  **요청** 
			## Request
			Request하는 컴퓨터 => 클라이언트
			```c++
			 
			/*<1.요청라인>*/  (HTTPMethod) /(요청URL) HTTP/(프로토콜버전)
			/*<2.Header>*/  HOST: (IP주소:포트번호 혹은 도메인) 
			/*<공백줄>*/ 
			/*<3.Body>*/    (서버에 보낼 데이터정보)
			```
			- HTTPMethod: 야 이거 하렴(무엇을 할지 알려주는 명령어)
				- GET(이 데이터 줘, 쿼리):  서버 데이터를 가져옴(읽기전용)
				- POST(이 새 데이터 생성해, 바디): 데이터를 서버에 전송
				- PUT(이 데이터 대치해, 바디): 서버 데이터를 전체 수정(덮어쓰기)
				- PATCH(이 데이터 일부 수정해, 바디): 서버 데이터를 부분수정
				- DELETE(이 데이터 삭제해, 쿼리): 서버의 데이터를 삭제
			- 요청에서 데이터를 전달하는 2가지 방식
				- 쿼리: 데이터를 내놓으라할때 상태라인에 조건을 쓰고 그조건을 쿼리라함
				- body: 데이터를 저장할때 아랫부분에 저장하고 body라한다
			- 요청 URL: 뭘? 이 데이터를 말야(서버에서 가져올 데이터 위치)
			- 프로토콜 버전: 이 방식으로 소통할께 (HTTP의 버전)
			- 서버에 보낼 데이터 정보: 사용자의 로그인 정보를보내 로그인 요청
		2.  HTTP  **응답**
			## Response
			Response하는 컴퓨터 => 서버
			```c++
			/*<1. 요청라인>*/HTTP/(프로토콜버전) (상태코드) (상태메세지)
			/*<2. Header>*/
						   Date: (응답 생성 시간)
						   Server: (서버종류)/(서버버전) 
						   Content-Type: (응답데이터의 타입)
						   Content-Length: (응답데이터 길이)
			/*<공백줄>*/ 
			/*<Body(본문)>*/(응답데이터)
			```
			- 프로토콜 버전 : “이 방식으로 소통했어!”
			- **Status Code**(상태코드) : “요청 결과가 어땠는지” 서버의 응답 상태를 나타내는 숫자 코드
			- **Status Message**(상태메세지): 상태코드를 사람이 이해하기 쉽게 표현한 메세지
			- 저 4개이외에 Response에 자주 사용되는 헤더
				```c++
				Set-Cookie: (쿠키설정) //클라이언트에세 쿠키 저장 요청
				Location: (리디렉션 수행할 주소) //location이 사용된다면 요청코드에 상태코드가 추가로 적힌다.
				Cache-Control: (캐시설정)//캐시정책설정(데이터 유지여부)
				```
				- 쿠키설정에 들어가는 속성
					- Path=/(쿠키를 사용할 경로설정);
					- Domain=(쿠키를 사용할 도메인지정);
					- HttpOnly;
						- 자바스크립트에서 접근불가능(보안강화)
					- Secure;
						- HTTPS에서만 전송가능
					- Expires=(쿠키만료일);
					- Max-Age=(쿠키가유효한 초단위)
					- SameSite=Strict;
						(CSRF 방지)
				- 리디렉션 주소
					- 서버가 클라이언트에게 **다른 URL로 이동하라고 지시하는 헤더**
					- 리디렉션(페이지 이동)
				- location사용될때 요청코드에 추가되는 상태코드
					- 영구적/일시적이동등을 지시한다.
				- 캐시 정책 설정
					- 클라이언트가 **어떤 데이터를 캐시할지, 얼마나 오래 유지할지**를 결정
				- 캐시 vs 쿠키
					- 캐시:  임시로 **웹사이트의 데이터**를 저장해서 웹사이트 속도를 빠르게** (똑같은 데이터 다시 다운x하고 불러오기)
					- 쿠키:  사용자 정보 저장 (보안위험있음)
			- body에  사용되는 데이터 유형
				- HTML :웹페이지 콘텐츠
				- JSON : API 응답데이터
				- XML : 구조화된 데이터
				- 파일데이터 ex) img,pdf 등
	- #### API는 **인터페이스**(프로그램들끼리의 대화수단)
		- **API** = **A**pplication **P**rogramming **I**nterface
		- 한 프로그램이 다른 프로그램의 기능을 사용하거나 데이터를 주고받을수 있도록 연결해주는 중간 역할을 하는 규칙
			- 정해진 약속을 하여 특정기능을 수행하는 것
			- 웹툰서버와 유저가 웹툰을 주고받기 위한 메뉴판
			- 유저가 웹툰을 가져오라는 코드를 어떻게 작동시켜~
			- 그래서 이 url로 get요청하면 웹툰 가져올수있게 하자 라는 코드를 작성 이때의 코드를 api라 한다.
			- 유저가 get요청하는 코드를 못짜는데요?
				- 브라우저의 주소창이 유저가 api요청 코드 짜는 곳이라고 보면된다(Get 요청하는)
				- 그리고 Html 이미지 누르면 get요청하게 해놓으면 되고~
		- **두 프로그램이 데이터를 교환할 때 “어떤 방식으로 대화할지 정의”**한 약속
		- 우리가 직접 코드를 짜지 않고도 특정 기능을 쉽게 사용할 수 있도록 제공되는 도구
		- API 종류
			- Web API(인터넷을 통한 소통 인터페이스 API)
				- REST API, GraphQL
			- OS API(운영체제가 제공하는 인터페이스 API)
			- Library API(특정기능를 쉽게 사용하게 해주는 API)
			- Hardware API(하드웨어와 소프트웨어가 소통하는 API)
	- REST API : 프로그램끼리의 대화수단인데, 데이터를 전송할때 HTTP형식으로 전송하는~
	- URL : 인터넷에서 **리소스의 주소** 
		- 리소스: 웹 페이지, 이미지, API 등
		- 프로토콜://도메인(서버주소)/리소스 위치?쿼리
			- ://은 구분기호
		- 즉 클라이언트가 url를 사용하여 요청을 보내면 서버는 HTTP 응답을 반환
	- 이해안가서 일단 정리한 순서
		- 저 위의 HTTP요청(클라이언트->서버)/ HTTP 응답(서버->클라이언트)의 양식은 유저나, 개발자가 직접작성하는게 아님
			- 유저가 직접 작성하지 않아도 API 클라이언트(**웹 브라우저, Postman, 프론트엔드 코드(fetch, axios))가 HTTP 요청을 자동 생성함.** 
				- **API 클라이언트는 API 요청을 보낼 수 있도록 해주는 프로그램 또는 도구를 의미**
			- **Spring 같은 백엔드 프레임워크가 요청을 자동으로 해석하고 처리해 줌**
		- **API가 동작하는 전체 과정은 “클라이언트 → 서버 → 데이터베이스 → 서버 → 클라이언트” 순서로 진행됨.**
		- 
		
- ### 1_5 GET API 개발하고 테스트
	- cmd+n :새로운 패키지/파일..등 만들기
	- ### option+⬆️: 범위지정 
		- 계속화살표위 누르면 범위가 커진다.
	- control+option+o : 안쓰는 import문 삭제
- 두개의 숫자를 받아 덧셈결과를 반환하는 api를 만들어보자.
	- 일단 나는 REST API를 쓸거야(HTTP요청을 사용하는)
	- 1. API Spec(ification) : 어떻게 api를 만들지?  
	    - HTTP Method -> GET   
		- HTTP Path -> /add   
		- 쿼리(key와 value) -> int number1/ int number2    
		- API의 반환결과 -> int
	- 2. 실제코딩
		- api를 개발할려는 클래스위에 @RestController를 적어주기
			- @RestController
				- 주어진 클래스를 컨트롤러로 등록한다
				- 컨트롤러: api의 진입지점
			- 그래서 클래스 안에 메서드를 만들어 api가 메서드 사용하도록 할수있다
		- 클래스 안에 @GetMapping()를 적고 ()안에 path를 적는다.
			- 이때의 Get이 HTTP 요청의 get이다
			- @GetMapping("/add")
				- 아래의 함수를 HTTP Method가 GET이고, HTTP path가 /add인 API로 지정한다.
		- 그리고 그 아래 기능을 구현한 함수를 만들어준다
			- 이때 함수가 쿼리를 통해 넘어온 데이터를 받아준다면, 매개변수 앞에 @RequestParam 이라고 적어준다.
			- @RequestParam
				- 주어지는 쿼리 파라미터값을 개별매걔변수에 넣어준다.
				- GET /add?number1=10&number2=20로 http를 통해 호출하면
				- 같은이름을 가진 쿼리의 값이 argument로 들어오게 된다.
	- 3. POSTMAN으로 만들어진 API테스트.
		- Postman키고 Get 누르고 주소창에 http://localhost:8080/.add
			- localhost :내컴퓨터라는 뜻
			- 8080: 서버동작하고있는 포트번호
		- 그리고 아래 params에 Key(변수이름) Value(변수 값)을 넣어준뒤 send를 클릭한다
			- Postman이 Url를 쉽게 작성해주고
			- send를 누르는순간 포스트맨이 http요청을 보내고 응답을 받는다.
	- @RequestParam를 매개변수에 넣어주면 많은값을 받을때 문제가 있다.
		- controller에서 @RequestParam를 제거하자!
		- 그리고 매개변수에는 객체를 받아준다.
		- how?
			- 새로운 클래스를 만들고 그 객체를 매걔변수로 받아준다. 
			- **Spring에서는 컨트롤러의 메서드 매개변수가
				- **기본 타입 (int, String 등)** 인경우→ @RequestParam 자동 적용
				- “객체(DTO)“인경우 기본적으로 매걔변수 앞에 @ModelAttribute를 적용한다
				- 이때 	DTO가 불변객체이면  **기본 생성자 & Setter가있어야** @ModelAttribute를 사용할수있다.
		- **DTO(Data Transfer Object, 데이터 전송 객체)**
			➡ **DTO 자체는 데이터를 전달하는 용도일 뿐, “쿼리 파라미터를 받는 클래스”가 되는 것은 아님!**
			✔ **DTO는 단순히 데이터를 담는 역할**
			✔ **어떻게 데이터를 받을지는 컨트롤러에서 어노테이션으로 결정됨**


- ### 1_6 POST API 개발하고 테스트하기
	- **POST 요청은 서버 데이터를 변경할 때 주로 사용되지만, 단순한 연산 API도 POST로 구현할 수 있다.**
	- **GET API에서는** 요청라인의 **쿼리 파라미터(Query Parameter) 또는 URL Path Variable**을 이용해 서버에 데이터를 전달한다.
		- 서버(API)는 URL에서 값을 읽어서 처리
	- **POST API**에서는 **HTTP Body** 이용해 데이터를(JSON형태로) 보낸다.
		- **Body에 데이터를 담아서 보내면**, API는 Body의 내용을 읽어서 정보를 가져온다.
			- Body 안에 **JSON 데이터**를 포함하여 전송
			- API는 **Body의 데이터를 읽어서 처리**
		- **Body에 데이터를 담을 때 주로 사용하는 문법이 JSON이다.**
		- 하지만 **JSON 외에도 XML, Form-Data 등 다양한 형식이 사용될 수 있다.**
		- JSON(JavaScript Object Notation)
			{ "key" : "value" }
			- 예시
				{
				"name": "최태현",
				"age": 99,
				"dogs": \["코코", "초코"],
				"house": {
					"address": "대한민국 서울",
					"hasDoor": true
					}
				}
				- Json의 속성 각각은 쉼표로 구분한다.
				- Json의 value에는 List가 올 수도 있다.
				- Json의 value에는 다른 JSON이 올수도 있다
	- 1. 곱셈기능을 POSTAPI로 만들어보자(GET으로 만들수도 있긴하지만~)
		- HTTP Method -> POST
		- HTTP Path -> /multiply
		- HTTP Body(JSON) -> {
							"number1":숫자,
							"number2":숫자
							}
		- API의 반환결과 -> int(곱셈결과)
	- 2. 코드 작성
		- 한 Controller Class에 여러 API를 추가할수있다
			- @RestController를 적힌 클래스 안에 @PostMapping()를 적고 ()안에 path를 적는다.
			- 이때의 Post이 HTTP 요청의 Post이다
			- @PostMapping("/multiply")
				- 아래의 함수를 HTTP Method가 Post이고, HTTP path가 /multiply인 API로 지정한다.
		- 그리고 그 아래 기능을 구현한 함수를 만들어준다
			- **클라이언트가 JSON 데이터를 HTTP Body에 담아 요청하면,**, 매개변수 앞에 @Requestbody 이라고 적어준다.
			- @Requestbody
				- **HTTP Body(JSON)를 DTO 객체로 변환하는 역할을 한다.**
	- **@RequestBody** ? @RequestParam?
		✔ **@RequestBody는 JSON 데이터를 DTO 객체로 변환해야 하기 때문에 자동 변환이 필요**
		
		✔ **@RequestParam은 URL에서 개별 값으로 전달되므로, DTO 변환 없이 기본 타입으로 바로 받을 수 있음**
			✔ **URL에 포함된 데이터를 바로 개별 변수로 받을 수 있으므로, DTO 객체로 변환할 필요가 없음**
			✔ **쿼리 파라미터는 항상 문자열(String)로 전달되므로, Spring이 기본 타입(int, double 등)으로 자동 변환 가능**
		
		✔ **둘 다 “데이터를 받는 역할”이지만, 데이터의 위치(Body vs Query Parameter)와 처리 방식이 다름**
		
		👉 **즉, @RequestBody는 JSON을 DTO로 변환해야 하고, @RequestParam은 URL의 값을 바로 사용할 수 있기 때문에 객체 변환이 필요 없다!**
- **📌 @RequestBody, @RequestParam, @ModelAttribute 차이점 & 생략 가능 여부 정리**
	**✅ 1. @RequestBody 언제 사용?**
	
	**📌 JSON 데이터를 DTO 객체로 변환할 때**
	✔ **생략 불가능 → @RequestBody를 명시해야 JSON 데이터가 DTO 객체로 변환됨**
	
	---
	
	**✅2. @RequestParam 언제 사용?**
	**📌 URL의 Query Parameter에서 개별 값을 받을 때**
	✔ **GET 요청에서 개별 쿼리 파라미터 값을 받을 때 사용**
	✔ **String, int 같은 기본 타입 데이터를 받을 때 자동적용(생략 가능)**
	
	---
	
	**✅ 3. @ModelAttribute 언제 사용?**
	**📌 Query Parameter 또는 Form 데이터를 객체(DTO)로 변환할 때**
		✔ **GET 요청에서 여러 개의 쿼리 파라미터를 한 번에 객체로 받고 싶을 때 사용**
		✔ **Spring이 자동으로 Query Parameter 값을 DTO 필드에 매핑**
		✔ **DTO 클래스에 기본 생성자와 Setter가 필요**
		✔ **DTO 객체로 받을 경우 생략 가능 (@ModelAttribute 자동 적용됨)**
-  **✅ @RequestBody, @RequestParam, @ModelAttribute 비교표**

| **어노테이션**           | **데이터 위치**                    | **변환 결과**                 | **변환 방식**                                            | **주요 용도**                       | **생략 가능 여부**           |
| ------------------- | ----------------------------- | ------------------------- | ---------------------------------------------------- | ------------------------------- | ---------------------- |
| **@RequestBody**    | **HTTP Body (JSON, XML 등)**   | **DTO 객체**                | **Spring의 HttpMessageConverter를 통해 변환 (Jackson 사용)** | **POST, PUT에서 JSON 데이터를 받을 때**  | ❌ 생략 불가능               |
| **@RequestParam**   | **URL의 Query Parameter**      | **기본 타입 (int, String 등)** | **Spring이 자동 변환**                                    | **GET 요청에서 개별 값(쿼리 파라미터) 받을 때** | ✅ 생략 가능 (기본 타입만)       |
| **@ModelAttribute** | **Query Parameter, Form 데이터** | **DTO 객체**                | **Spring이 자동으로 객체 매핑**                               | **GET 요청에서 DTO 객체로 받을 때**       | ✅ 생략 가능 (DTO 타입 매개변수만) |


- ### 1_7  유저 생성 API 개발
	- 원래 api는 서버개발자가 내키는대로 만드는게 아님
	- 클라이언트 개발자(프론트)랑 서버 개발자(백엔드)랑 모여서 api를 같이 의논하고 설계하고 확정함
		- ui가 이미 만들어져 있으면 거기에 맞춰서 api를 만드는거임
	-  **도메인 기반/ 기능별(모듈별) 패키지 구조**: **사용자 관련 API는 user 패키지, 책 관련 API는 book 패키지에 정리**
	-  **int는 기본 타입(Primitive Type)이고, Integer는 객체(Wrapper Class)이기 때문에 Integer는 Null를 저장할수있다.**
		- 그래서 입력이 선택적인경우 wrapper class를 사용한다
- Request폴더를 생성해서하는 이유 Response와 구분하기 위해서
```
/src/main/java/com/example/libraryapp/dto
│── /calculator
│── /user
│   ├── /request  <-- (요청 DTO를 관리하는 폴더)
│   │   ├── UserCreateRequest.java  <-- 사용자 생성 요청 DTO
│   ├── /response  <-- (응답 DTO를 관리하는 폴더)
│   │   ├── UserResponse.java  <-- 사용자 정보 응답 DTO
```
```Java
@RestController
public class UserController {
    @PostMapping("/user")
    public void saveUser(@RequestBody UserCreateRequest request) {
        // 데이터 저장 로직 없음 -> DB에 저장되지 않음!
        /*
        ✔ **컨트롤러는 UserCreateRequest 객체를 받아들이지만, 실제 데이터 저장 기능이 없음**

✔ **이 상태에서는 클라이언트에서 요청을 보내도 데이터베이스(DB)에 저장되지 않음**
        */
    }
}
```
- 📌서버에 **데이터를 저장하려면 아래 3가지가 필요함**
	1. **Entity (User 엔티티, 도메인 모델)** → DB 테이블과 매핑될 객체(데이터 저장할 그릇)
	2. **Repository (UserRepository)** → 데이터베이스와 연결
		- ✅ **Repository 계층은 데이터베이스(DB)와 직접 연결되는 역할**
		- ✅ **UserRepository 없이 Controller에서 DB를 직접 다루면 유지보수성이 떨어짐**
	3. **Service (UserService)** → 비즈니스 로직 처리(복잡한 연산, 트랜잭션 관리, 여러 개의 Repository 조합)
	- domain : 애플리케이션에서 다루는 **핵심 비즈니스 개념**
		- 예를 들어, **“사용자(User), 책(Book), 주문(Order)”** 같은 핵심 데이터를 의미
- **컨트롤러는 “API 요청을 처리하는 기능”만 수행해야 하고, 데이터 저장(비즈니스 로직)은 Service에서 수행해야 합니다.**	
	✔ 클라이언트(프론트엔드)에서 보낸 요청을 받고, 적절한 서비스를 호출한 후 응답을 반환해야 함.
	✔ 하지만 **컨트롤러가 직접 DB를 다루면, API 요청 처리 + 데이터 저장까지 담당해야 하므로 역할이 애매해짐.**
	-> **컨트롤러는 Service를 호출하여 데이터 저장**하도록 하면됨
- 비즈니스 로직: 서비스의 핵심동작을 처리하는 로직
	- 단순히 데이터를 저장하는것이 아니라 어떤기준으로 데이터를 저장/조회/처리 할것인가를 결정하는로직
	- 즉 서비스의 핵심 기능을 정의하는것
	- 사용자가 입력한 결제 정보 저장하기에 비즈니스 로직을 추가하면
		- 카드 유효성 체크, 포인트 적용 후 저장하는게 추가된다

- ### 1_8  유저 조회 API 개발
	- API 스펙(spec, 설계문서)
		- "API 문서” 또는 “API 명세서”라고도 부름
		- API가 어떻게 동작하는지를 정의한 **설계 문서**
		- • 클라이언트(프론트엔드)와 서버(백엔드)가 원활하게 통신할 수 있도록 **API의 구조, 입력값, 출력값, 요청 방식 등을 명확히 정의**
	- 유저 조회 API 스펙
		- HTTP Method ->GET
		- HTTP Path -> :/user
		- 쿼리 -> 없음
		- 결과반환 ->
			{
			
			}